<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单调队列</title>
      <link href="/posts/d9f45d1f.html"/>
      <url>/posts/d9f45d1f.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单调栈</title>
      <link href="/posts/16518a5d.html"/>
      <url>/posts/16518a5d.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划--树形DP</title>
      <link href="/posts/bc675241.html"/>
      <url>/posts/bc675241.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104 二叉树的最大深度</a></td><td style="text-align:center">easy</td><td style="text-align:center">递归</td><td style="text-align:center">9.04</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543 二叉树的直径</a></td><td style="text-align:center">easy</td><td style="text-align:center">树形DP</td><td style="text-align:center">9.04</td><td style="text-align:center"></td><td>边权型</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124 二叉树中的最大路径和</a></td><td style="text-align:center">hard</td><td style="text-align:center">树形DP</td><td style="text-align:center">9.04</td><td style="text-align:center"></td><td>点权型</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/">2246 相邻字符不同的最长路径</a></td><td style="text-align:center">hard</td><td style="text-align:center">树形DP</td><td style="text-align:center">9.04</td><td style="text-align:center"></td><td>建树</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/house-robber-iii/">337 打家劫舍 III</a></td><td style="text-align:center">medium</td><td style="text-align:center">树形DP</td><td style="text-align:center">9.04</td><td style="text-align:center"></td><td>树上最大独立集</td></tr><tr><td style="text-align:center">337变形</td><td style="text-align:center"><a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会</a></td><td style="text-align:center">普及</td><td style="text-align:center">树形DP(非二叉树)</td><td style="text-align:center"></td><td style="text-align:center"></td><td>树上最大独立集</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-cameras/">968 监控二叉树</a></td><td style="text-align:center">hard</td><td style="text-align:center">树形DP</td><td style="text-align:center">9.05</td><td style="text-align:center"></td><td>树上最小支配集</td></tr><tr><td style="text-align:center">968变形</td><td style="text-align:center"><a href="https://www.luogu.com.cn/problem/P2458">P2458 保安站岗</a></td><td style="text-align:center">提高</td><td style="text-align:center">树形DP(非二叉树)</td><td style="text-align:center"></td><td style="text-align:center"></td><td>树上最小支配集</td></tr><tr><td style="text-align:center">练习</td><td style="text-align:center"><a href="https://leetcode.cn/problems/longest-univalue-path/">687 最长同值路径</a></td><td style="text-align:center">medium</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">练习</td><td style="text-align:center"><a href="https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees/">3203 合并两棵树后的最小直径</a></td><td style="text-align:center">hard</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><h1>104 二叉树的最大深度</h1><p>最大深度 = max(左子树的最大深度, 右子树的最大深度) + 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>        <span class="comment"># 空节点的深度为0      </span></span><br><span class="line">            <span class="comment"># 叶子节点: 0+0+1 = 1    </span></span><br><span class="line">            left = dfs(node.left)</span><br><span class="line">            right = dfs(node.right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dfs(root)</span><br></pre></td></tr></table></figure><h1>543 二叉树的直径</h1><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725420996096.webp" alt="1725420996096.png"><br>在 2 拐弯， 1 的链长 0 ， 3 的链长 1， 然后 0 + 1 + 2 = 3<br>任意两个节点之间最长路径的 <strong>长度</strong></p><blockquote><p>2 是连接node 和左右子树的两条路径<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725421407249.webp" alt="1725421407249.png"></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">diameterOfBinaryTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>  <span class="comment"># 叶子节点: left=0,right=0,返回给父节点=0</span></span><br><span class="line">            left = dfs(node.left) + <span class="number">1</span>  <span class="comment"># 加上连接子树的链长</span></span><br><span class="line">            right = dfs(node.right) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            ans = <span class="built_in">max</span>(left + right, ans) <span class="comment"># 更新答案</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left, right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>时间复杂度: O(n) 每个点都遍历了一次<br>空间复杂度: O(n) 最坏情况下这个二叉树是一条链，递归需要O(n)的栈空间</p><h1>124 二叉树中的最大路径和</h1><p>枚举拐弯的位置计算 左右子树的最大链和，ans 时，需要加上当前node 的值<br>存在负数，如何处理：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725429630565.webp" alt="1725429630565.png"></p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725429687035.webp" alt="1725429687035.png"><br><strong>负数的处理： 以2 的左子树为例，它的结果是负数， 返回0，表示不能选左边</strong><br>例如：<br>root = [2,-1]， 预期 = 2，但是算的 = 1</p><h1>2246 相邻字符不同的最长路径</h1><p>x 和 y 之间有边相连， x 是 y 的邻居， y 是 x 的邻居<br>二叉树中，一个node最多有三个邻居，左儿子，右儿子和父节点。<br>而在一般树中，邻居的个数是不定的。需要用 for 循环去挨个遍历它的邻居<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240904143405.webp" alt="image.png"></p><ol><li>因为求得是直径，所以取最大的两个</li><li>遍历的同时去维护最大值<br>以思路二求解：</li></ol><h2 id="最长-次长思路">最长_次长思路</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPath</span>(<span class="params">self, parent: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 建树 ： 节点编号都在 n 以内的话，用list就行，否则用哈希</span></span><br><span class="line">        n = <span class="built_in">len</span>(parent)</span><br><span class="line">        g = [ [] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 0 是根节点，这条边不存在，从1开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># parent[i] --&gt; i 的边</span></span><br><span class="line">            g[parent[i]].append(i)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            x_len = <span class="number">0</span>         <span class="comment">#维护最长路径 </span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> g[x]:</span><br><span class="line">                <span class="comment"># x 的邻居</span></span><br><span class="line">                y_len = dfs(y) + <span class="number">1</span>  <span class="comment"># 加上 x --&gt; y 的边</span></span><br><span class="line">                <span class="keyword">if</span> s[y] != s[x]:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, x_len + y_len)  <span class="comment"># 算的是边的数目</span></span><br><span class="line">                    x_len = <span class="built_in">max</span>(x_len, y_len)      <span class="comment"># 更新最长路径 </span></span><br><span class="line">            <span class="keyword">return</span> x_len</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>  <span class="comment"># 要求节点数据</span></span><br></pre></td></tr></table></figure><h2 id="扩展（邻居包含父节点）">扩展（邻居包含父节点）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPath</span>(<span class="params">self, parent: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 建树 ： 节点编号都在 n 以内的话，用list就行，否则用哈希</span></span><br><span class="line">        n = <span class="built_in">len</span>(parent)</span><br><span class="line">        g = [ [] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 0 是根节点，这条边不存在，从1开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            <span class="comment"># parent[i] --&gt; i 的边</span></span><br><span class="line">            g[parent[i]].append(i)   <span class="comment"># 邻接表</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">x, fa</span>):     <span class="comment">#  fa是x的父节点</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            x_len = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> g[x]:</span><br><span class="line">                <span class="comment"># x 的邻居</span></span><br><span class="line">                <span class="keyword">if</span> y == fa : <span class="keyword">continue</span>  </span><br><span class="line">                y_len = dfs(y, x) + <span class="number">1</span>  <span class="comment"># 加上 x --&gt; y 的边</span></span><br><span class="line">                <span class="keyword">if</span> s[y] != s[x]:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, x_len + y_len)</span><br><span class="line">                    x_len = <span class="built_in">max</span>(x_len, y_len)</span><br><span class="line">            <span class="keyword">return</span> x_len</span><br><span class="line">        dfs(<span class="number">0</span>, -<span class="number">1</span>)     <span class="comment"># root 没有父节点</span></span><br><span class="line">        <span class="keyword">return</span> ans  + <span class="number">1</span></span><br></pre></td></tr></table></figure><h1>337 打家劫舍 III</h1><p>不能选相邻的节点，选了根节点后，它的左右儿子都不能选。如何使选到的数字之和最大。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240904215559.webp" alt="image.png"><br>同数组版打家劫舍，如果不选第 i 个数，那么可以从第 i - 1 个数转移过来。如果选第 i 个数，需要跳过 i - 1, 从 i - 2个数转移过来。<br>i - 2 相当于 儿子的儿子，最多要考虑四个节点，情况有点多。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240904215921.webp" alt="image.png"><br>相当于状态机的思想。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240904220314.webp" alt="image.png"><br>当2 不选时，它的两个子树选or不选都可以，所以6+6=12。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240904220426.webp" alt="image.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># retrun 选 or 不选的最大点权和</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            l_rob, l_no_rob = dfs(node.left)</span><br><span class="line">            r_rob, r_no_rob = dfs(node.right)</span><br><span class="line">            rob = l_no_rob + r_no_rob + node.val    </span><br><span class="line">            no_rob = <span class="built_in">max</span>(l_rob, l_no_rob) + <span class="built_in">max</span>(r_rob, r_no_rob)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> rob, no_rob</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        root_rob, root_no_rob = dfs(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(root_rob, root_no_rob)</span><br></pre></td></tr></table></figure><p>时空复杂度都是 $O(n)$ 的</p><h2 id="总结">总结</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240904221759.webp" alt="image.png"><br>如果点权都是1，算出来的就是最大独立集。</p><h1>P1352 没有上司的舞会</h1><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240904221655.webp" alt="image.png"></p><h1>968 监控二叉树</h1><h2 id="思路">思路</h2><p>每个摄像头，可以监视其父节点、自身和子节点</p><ol><li>根节点不装 --&gt; 至少有一个儿子要装摄像头</li><li>其他情况<img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905133008.webp" alt="image.png"></li><li>子树根节点为蓝色，它的左右儿子什么颜色都可以选。分别枚举左右儿子的颜色<img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905134140.webp" alt="image.png">+1表示子树的根节点装了一个摄像头</li><li>子树根节点为黄色，黄色节点的儿子不可能是黄色<img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905134404.webp" alt="image.png"></li><li>子树根节点为红色，红色至少有一个儿子安装摄像头。所以红色节点的儿子不可能是黄色，且至少一个儿子是蓝色。<img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905134601.webp" alt="image.png"><br>3 中：</li></ol><blockquote><p>根节点</p></blockquote><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905134702.webp" alt="image.png"><br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905134708.webp" alt="image.png"><br>把空节点当作递归边界，如果空节点为蓝色，用inf表示不合法。<br>return inf, 0, 0 分别表示蓝色，黄色，红色的数目</p><h2 id="树形DP代码">树形DP代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCameraCover</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="comment"># 递归边界</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> inf, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            l_choose, l_by_fa, l_by_son = dfs(node.left)  <span class="comment"># 左子树</span></span><br><span class="line">            r_choose, r_by_fa, r_by_son = dfs(node.right) <span class="comment"># 右子树</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 当前节点的 选 or fa or son</span></span><br><span class="line">            choose = <span class="built_in">min</span>(l_choose, l_by_fa, l_by_son) + <span class="built_in">min</span>(r_choose, r_by_fa, r_by_son) + <span class="number">1</span></span><br><span class="line">            by_fa = <span class="built_in">min</span>(l_choose, l_by_son) + <span class="built_in">min</span>(r_choose, r_by_son)</span><br><span class="line">            by_son = <span class="built_in">min</span>(l_choose + r_by_son, l_by_son + r_choose, l_choose + r_choose)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> choose, by_fa, by_son</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根节点</span></span><br><span class="line">        choose, _, by_son = dfs(root)  <span class="comment"># 根节点没有父节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(choose, by_son)     <span class="comment"># min(根节点安装， 根节点儿子安装)</span></span><br></pre></td></tr></table></figure><p>时间复杂度: $O(N)$ 每个节点都递归到一次<br>时间复杂度: $O(N)$ 最坏情况下(只有左儿子没有右儿子)，成为一条链，递归需要$O(N)$的栈空间</p><h2 id="变形1">变形1</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905140107.webp" alt="image.png"><br>相当于每个节点的花费都是1，直接把1改成node的花费即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choose = <span class="built_in">min</span>(l_choose, l_by_fa, l_by_son) + <span class="built_in">min</span>(r_choose, r_by_fa, r_by_son) + cost[node]</span><br></pre></td></tr></table></figure><h2 id="变形2">变形2</h2><p>扩展到一般树<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905141535.webp" alt="image.png"></p><p>如果有3个儿子，每个儿子蓝色 or 红色，一共有$2<em>2</em>2=8$种情况，减去都是红色的情况，一共7种情况。<br>4个儿子:有15种情况<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905142015.webp" alt="image.png"></p><p>最终公式：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/20240905142149.webp" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划--区间DP</title>
      <link href="/posts/454a8e26.html"/>
      <url>/posts/454a8e26.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/">516 最长回文子序列</a></td><td style="text-align:center">medium</td><td style="text-align:center">区间DP</td><td style="text-align:center">9.03</td><td style="text-align:center"></td><td>常考</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/">1039 多边形三角剖分的最低得分</a></td><td style="text-align:center">medium</td><td style="text-align:center">区间DP</td><td style="text-align:center">9.03</td><td style="text-align:center"></td><td>妙啊</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">medium</td><td style="text-align:center">区间DP</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">hard</td><td style="text-align:center">区间DP</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><h1>516 最长回文子序列</h1><h2 id="转换">转换</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725335633607.webp" alt="1725335633607.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        reversed_s = s[::-<span class="number">1</span>]</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 求 s 和 reversed_s 的 LCS</span></span><br><span class="line">        <span class="comment"># 四种情况分析</span></span><br><span class="line">        @ cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="comment"># 边界</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == reversed_s[j]:</span><br><span class="line">                <span class="keyword">return</span> dfs(i - <span class="number">1</span>, j - <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i - <span class="number">1</span>, j), dfs(i, j - <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>, n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="区间DP">区间DP</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725335728430.webp" alt="1725335728430.png"><br>类似于最长公共子序列的思考方式：<br>e和a 不同，不能都选，要么不选e，要么不选a</p><h3 id="递归">递归</h3><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725343802247.webp" alt="1725343802247.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># s[i] == s[j] dfs(i, j) = dfs(i+1, j-1) + 1</span></span><br><span class="line">        <span class="comment"># s[i] != s[j] dfs(i, j) = max(dfs(i+1, j), dfs(i, j-1))</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        @ cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i == j:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; j :</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                <span class="keyword">return</span> dfs(i+<span class="number">1</span>, j-<span class="number">1</span>) + <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i+<span class="number">1</span>, j), dfs(i, j-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>时间复杂度分析：<br>由于状态有$O(n^2)$个，每个状态只需要$O(1)$的时间计算，所以时间复杂度是$O(n^2)$的</p><h3 id="递推">递推</h3><p>为啥这里不用把 j 后移<br>因为 $i \in [n-1, 0],j \in [1,n-1]$，所以不用把 j 后移一位</p><blockquote><p>这里 i 和 j 遍历的顺序非常重要</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindromeSubseq</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># s[i] == s[j] f[i][j] = f[i+1][j-1] + 2</span></span><br><span class="line">        <span class="comment"># s[i] != s[j] f[i][j] = max(f[i+1][j], f[i][j-1])</span></span><br><span class="line">        <span class="comment"># 边界 i = j ,f = 1 ; i &gt; j, f = 0</span></span><br><span class="line">        <span class="comment"># i + 1 --&gt; i 倒序  j - 1 --&gt; j 正序</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        f = [[<span class="number">0</span>] * (n) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span> (n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># [n-1, 0 ]</span></span><br><span class="line">            f[i][i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):  <span class="comment"># [i+1, n-1]</span></span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    f[i][j] = f[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = <span class="built_in">max</span>(f[i+<span class="number">1</span>][j], f[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="空间优化">空间优化</h4><h1>1039 多边形三角剖分的最低得分</h1><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725345194860.webp" alt="1725345194860.png"><br>子问题就是枚举K，组成不同得分的三角形。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725345621440.webp" alt="1725345621440.png"><br>剩下的两个多边形：</p><ol><li>从 i 顺时针走到 k ，然后再直接从 k 到 i</li><li>从 k 顺时针走到 j ，然后再直接从 j 到 k</li></ol><h2 id="递归-2">递归</h2><p>得到递推式为:<br>固定 i , j ，枚举 k , $k \in [i+1, j-1]$<br>$$dfs(i,j) = min(dfs(i,k) + dfs(k,j) + v[i] * v[j] * v[k])$$</p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725345971567.webp" alt="1725345971567.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minScoreTriangulation</span>(<span class="params">self, values: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(values)</span><br><span class="line">        @ cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> == j : <span class="comment"># 中间不含点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            res = inf</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, j):</span><br><span class="line">                res = <span class="built_in">min</span>(res, dfs(i,k) + dfs(k,j) + values[i]*values[j]*values[k])</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>时间复杂度 ： $O(n^3)$</p><h2 id="递推-2">递推</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725346983536.webp" alt="1725346983536.png"></p><blockquote><p>这里的顺序十分重要</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minScoreTriangulation</span>(<span class="params">self, values: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(values)</span><br><span class="line">        <span class="comment"># dfs(i, j) = min( dfs(i,k) + dfs(k,j) + values[i]*values[j]*values[k] )</span></span><br><span class="line">        <span class="comment"># f[i][j] = min( f[i][k] + f[k][j] + values[i]*values[j]*values[k] )</span></span><br><span class="line">        <span class="comment"># 边界 f[i][i+1] = 0</span></span><br><span class="line">        f = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">2</span>, n):</span><br><span class="line">                res = inf</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span> (i + <span class="number">1</span>, j):</span><br><span class="line">                    res = <span class="built_in">min</span>(res, f[i][k] + f[k][j] + values[i]*values[j]*values[k] )</span><br><span class="line">                f[i][j] = res</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划--状态机DP</title>
      <link href="/posts/6debdf55.html"/>
      <url>/posts/6debdf55.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th></th></tr></thead><tbody><tr><td style="text-align:center">面试150</td><td style="text-align:center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121 买卖股票的最佳时机</a></td><td style="text-align:center">easy</td><td style="text-align:center">状态机DP</td><td style="text-align:center">9.02</td><td style="text-align:center"></td><td>常考</td></tr><tr><td style="text-align:center">面试150</td><td style="text-align:center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122 买卖股票的最佳时机 II</a></td><td style="text-align:center">medium</td><td style="text-align:center">状态机DP</td><td style="text-align:center">9.02</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">变形</td><td style="text-align:center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309 买卖股票的最佳时机含冷冻期</a></td><td style="text-align:center">medium</td><td style="text-align:center">状态机DP</td><td style="text-align:center">9.02</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">变形</td><td style="text-align:center"><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188 买卖股票的最佳时机 IV</a></td><td style="text-align:center">hard</td><td style="text-align:center">状态机DP</td><td style="text-align:center">9.02</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><h1>121 买卖股票的最佳时机</h1><h2 id="递归">递归</h2><p>递归会超时</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 状态为最大利润</span></span><br><span class="line">        <span class="comment"># dfs(i, minprice, maxprofit) = max(dfs(i-1, minprice, maxprofit), price[i] - minprice)</span></span><br><span class="line">        <span class="comment"># dfs(i, minprice, maxprofit) = max(maxprofit, price[i] - minprice)</span></span><br><span class="line">        <span class="comment"># 从 i-1天 --&gt; i天： 第i天不卖出 或者 第i天卖出(在前面取最低价格的基础上)</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, minprice, maxprofit</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                <span class="keyword">return</span> maxprofit</span><br><span class="line">            <span class="comment"># 更新最低价格</span></span><br><span class="line">            minprice = <span class="built_in">min</span>(minprice, prices[i])  <span class="comment">#  i 前面的 minprice --&gt; 正序遍历</span></span><br><span class="line">            <span class="comment"># 最高利润</span></span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, prices[i] - minprice)</span><br><span class="line">            <span class="keyword">return</span> dfs(i + <span class="number">1</span>, minprice, maxprofit)</span><br><span class="line">        <span class="comment"># return dfs(0, float(&#x27;inf&#x27;), 0)</span></span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, inf, -inf)</span><br></pre></td></tr></table></figure><p>错误：更新minprice 只需要和prices[i] 比较就行</p><h2 id="递推">递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dfs(i) = max(dfs(i-1), prices[i] - minprice)</span></span><br><span class="line">        <span class="comment"># f[i] = max(f[i-1], prices[i] - minprice)</span></span><br><span class="line">        <span class="comment"># f[i+1] = max(f[i], prices[i] - minprice)</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        f = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        minprice = inf</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            minprice = <span class="built_in">min</span>(minprice, prices[i])</span><br><span class="line">            f[i+<span class="number">1</span>] = <span class="built_in">max</span>(f[i], prices[i] - minprice)</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><h1>122. 买卖股票的最佳时机 II (不限交易次数)</h1><p>倒着思考<br>买入时利润记为 -4 , 卖出时记为 +4<br>子问题： 第$i$天结束时，持有 / 未持有股票的最大利润<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725277884964.webp" alt="1725277884964.png"></p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725279081016.webp" alt="1725279081016.png"></p><p>如果在第$i$天卖出股票，表示在这一天开始的时候是有股票的，结束的时候是没有股票的。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725279179132.webp" alt="1725279179132.png"></p><h2 id="递归-2">递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(i,<span class="number">0</span>) = <span class="built_in">max</span>(dfs(i-<span class="number">1</span>,<span class="number">0</span>), dfs(i-<span class="number">1</span>,<span class="number">1</span>)+price[i])</span><br><span class="line">dfs(i,<span class="number">1</span>) = <span class="built_in">max</span>(dfs(i-<span class="number">1</span>,<span class="number">1</span>), dfs(i-<span class="number">1</span>,<span class="number">0</span>)-price[i])</span><br></pre></td></tr></table></figure><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725279341931.webp" alt="1725279341931.png"><br>dfs(-1, 0)表示第-1天结束时未持有股票，即为第0天开始时未持有股票。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725279464644.webp" alt="1725279464644.png"><br>如果第n-1天还持有股票，这个股票卖不出去了，所以不必考虑这个情况。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        @cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, hold</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> -inf <span class="keyword">if</span> hold <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> hold : <span class="comment"># 第i天持有</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>,<span class="number">1</span>), dfs(i-<span class="number">1</span>,<span class="number">0</span>) - prices[i]) <span class="comment"># 买入 or 摆烂</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>,<span class="number">0</span>), dfs(i-<span class="number">1</span>,<span class="number">1</span>) + prices[i]) <span class="comment"># 卖出 or 摆烂</span></span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="递推-2">递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f[i][<span class="number">0</span>] = <span class="built_in">max</span>( f[i-<span class="number">1</span>][<span class="number">0</span>], f[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">f[i][<span class="number">1</span>] = <span class="built_in">max</span>( f[i-<span class="number">1</span>][<span class="number">1</span>], f[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line"><span class="comment"># 没有状态表示边界状态</span></span><br><span class="line"><span class="comment"># 将f中的i向后移1位， price中的不变</span></span><br><span class="line"><span class="comment"># 边界条件 f[0][0] = 0 f[0][1] = -inf</span></span><br><span class="line"><span class="comment"># 出口 f[n][0]</span></span><br><span class="line">f[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>( f[i][<span class="number">0</span>], f[i][<span class="number">1</span>] + prices[i])</span><br><span class="line">f[i+<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>( f[i][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        f = [ [<span class="number">0</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">1</span>] = -inf</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            f[i+<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>( f[i][<span class="number">0</span>], f[i][<span class="number">1</span>] + prices[i])</span><br><span class="line">            f[i+<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>( f[i][<span class="number">1</span>], f[i][<span class="number">0</span>] - prices[i])</span><br><span class="line">        <span class="keyword">return</span> f[n][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="空间优化">空间优化</h3><p>由于f[i+1] 只用到了 f[i] 的状态 ，所以只需要两个变量, 空间复杂度优化为$O(1)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        f0 = <span class="number">0</span></span><br><span class="line">        f1 = -inf</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tmp = f0</span><br><span class="line">            f0 = <span class="built_in">max</span>( f0, f1 + prices[i])</span><br><span class="line">            f1 = <span class="built_in">max</span>( f1, tmp - prices[i])</span><br><span class="line">        <span class="keyword">return</span> f0</span><br></pre></td></tr></table></figure><h1>309 买卖股票的最佳时机含冷冻期</h1><p>买入股票的前一天不能有卖出操作(有点像打家劫舍)<br>今天买入 --&gt; 昨天不能卖出 --&gt; 前天不能持有  dfs(i-2, 0)<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725282045608.webp" alt="1725282045608.png"></p><h2 id="递归-3">递归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        @cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, hold</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> -inf <span class="keyword">if</span> hold <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> hold:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>, <span class="number">1</span>), dfs(i-<span class="number">2</span>, <span class="number">0</span>) - prices[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>, <span class="number">0</span>), dfs(i-<span class="number">1</span>, <span class="number">1</span>) + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="递推和优化">递推和优化</h2><p>这里有三个变量，递推和空间优化的写法<strong>参考打家劫舍</strong>。</p><h1>188 买卖股票的最佳时机 IV(至多交易K次)</h1><p>有买入，肯定有卖出，只需要做一次 $j-1$ 即可<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725283120534.webp" alt="1725283120534.png"></p><h2 id="递归-4">递归</h2><p>边界条件：<br><strong>需要综合考虑</strong><br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725283392183.webp" alt="1725283392183.png"><br>递归入口：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725283499776.webp" alt="1725283499776.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># j 表示交易次数,买入时交易次数-1</span></span><br><span class="line">        <span class="comment"># dfs(i,j,0) = max(dfs(i-1,j,0), dfs(i-1,j,1)+prices[i])</span></span><br><span class="line">        <span class="comment"># dfs(i,j,1) = max(dfs(i-1,j,1), dfs(i-1,j-1,0)-prices[i])</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        @cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j, hold</span>):</span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> -inf  <span class="comment"># 不合法方案</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> -inf <span class="keyword">if</span> hold <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> hold:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>, j, <span class="number">1</span>), dfs(i-<span class="number">1</span>, j-<span class="number">1</span>, <span class="number">0</span>) - prices[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>, j, <span class="number">0</span>), dfs(i-<span class="number">1</span>, j, <span class="number">1</span>) + prices[i])</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>, k, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="递推-3">递推</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725283910780.webp" alt="1725283910780.png"><br>没有把 j 加一， 是因为代码中的 j 从 1 开始</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># j 表示交易次数,买入时交易次数-1</span></span><br><span class="line">        <span class="comment"># f[i][j][0] = max(f[i-1][j][0], f[i-1][j][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># f[i][j][1] = max(f[i-1][j][1], f[i-1][j-1][0] - prices[i])</span></span><br><span class="line">        <span class="comment"># f 后移一位</span></span><br><span class="line">        <span class="comment"># f[][0][] = -inf</span></span><br><span class="line">        <span class="comment"># f[0][j][0] = 0  f[0][j][1] = -inf  其中j &gt;= 1 j从1到k+1,共k次交易</span></span><br><span class="line">        <span class="comment"># f[i+1][j][0] = max(f[i][j][0], f[i][j][1] + prices[i])</span></span><br><span class="line">        <span class="comment"># f[i+1][j][1] = max(f[i][j][1], f[i][j-1][0] - prices[i])</span></span><br><span class="line">        <span class="comment"># return f[n][k+1][0]</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        <span class="comment"># 三维数组</span></span><br><span class="line">        f = [[[-inf] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">2</span>):</span><br><span class="line">            f[<span class="number">0</span>][j][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">2</span>):</span><br><span class="line">                f[i+<span class="number">1</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">1</span>], f[i][j-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">                f[i+<span class="number">1</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">0</span>], f[i][j][<span class="number">1</span>] + prices[i])</span><br><span class="line">        <span class="keyword">return</span> f[n][k+<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="空间优化-2">空间优化</h3><p>因为$f[i+1]$只用到$f[i]$这个状态，所以可以去掉一个维度。<br>优化为$O(K)$的空间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        f = [[-inf] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">2</span>)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">2</span>):</span><br><span class="line">            f[j][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">2</span>):</span><br><span class="line">                <span class="comment"># f[i+1][j][1] = max(f[i][j][1], f[i][j-1][0] - prices[i])</span></span><br><span class="line">                <span class="comment"># f[i+1][j][0] = max(f[i][j][0], f[i][j][1] + prices[i])</span></span><br><span class="line">                tmp = f[j][<span class="number">1</span>]</span><br><span class="line">                f[j][<span class="number">1</span>] = <span class="built_in">max</span>(f[j][<span class="number">1</span>], f[j-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">                f[j][<span class="number">0</span>] = <span class="built_in">max</span>(f[j][<span class="number">0</span>], tmp + prices[i])</span><br><span class="line">        <span class="keyword">return</span> f[k+<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="恰好K次-至少K次">恰好K次 / 至少K次</h2><p>只需要修改初始化条件即可。</p><h3 id="恰好K次">恰好K次</h3><p>递归到 i&lt;0 时，只有 j=0 才是合法的，j&gt;0 是不合法的。<br>在第一天开始的时候，由于没有任何交易，所以认为恰好完成了0次。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725285153252.webp" alt="1725285153252.png"><br>$j$ 是从1开始的</p><h3 id="至少K次">至少K次</h3><p>递归到「至少 0 次」时，它等价于「交易次数没有限制」，那么这个状态的计算方式和 <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/solution/shi-pin-jiao-ni-yi-bu-bu-si-kao-dong-tai-o3y4/">122. 买卖股票的最佳时机 II</a> 是一样的。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725285253752.webp" alt="1725285253752.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 至少</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 递推</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        f = [[[-inf] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(prices):</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][<span class="number">0</span>][<span class="number">0</span>], f[i][<span class="number">0</span>][<span class="number">1</span>] + p)</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][<span class="number">0</span>][<span class="number">1</span>], f[i][<span class="number">0</span>][<span class="number">0</span>] - p)  <span class="comment"># 无限次</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, k + <span class="number">1</span>):</span><br><span class="line">                f[i + <span class="number">1</span>][j][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">0</span>], f[i][j][<span class="number">1</span>] + p)</span><br><span class="line">                f[i + <span class="number">1</span>][j][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j][<span class="number">1</span>], f[i][j - <span class="number">1</span>][<span class="number">0</span>] - p)</span><br><span class="line">        <span class="keyword">return</span> f[-<span class="number">1</span>][-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 记忆化搜索</span></span><br><span class="line">        <span class="comment"># @cache</span></span><br><span class="line">        <span class="comment"># def dfs(i: int, j: int, hold: bool) -&gt; int:</span></span><br><span class="line">        <span class="comment">#     if i &lt; 0:</span></span><br><span class="line">        <span class="comment">#         return -inf if hold or j &gt; 0 else 0</span></span><br><span class="line">        <span class="comment">#     if hold:</span></span><br><span class="line">        <span class="comment">#         return max(dfs(i - 1, j, True), dfs(i - 1, j - 1, False) - prices[i])</span></span><br><span class="line">        <span class="comment">#     return max(dfs(i - 1, j, False), dfs(i - 1, j, True) + prices[i])</span></span><br><span class="line">        <span class="comment"># return dfs(n - 1, k, False)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/posts/69c3279c.html"/>
      <url>/posts/69c3279c.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Tool_Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划--线性DP</title>
      <link href="/posts/cdef6d5e.html"/>
      <url>/posts/cdef6d5e.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><p>暑期休息三周，重新开始写</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th></th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143 最长公共子序列</a></td><td style="text-align:center">medium</td><td style="text-align:center">线性DP</td><td style="text-align:center">8.18</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/edit-distance/">72 编辑距离</a></td><td style="text-align:center">medium</td><td style="text-align:center">线性DP</td><td style="text-align:center">8.19</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300 最长递增子序列</a></td><td style="text-align:center">medium</td><td style="text-align:center">线性DP</td><td style="text-align:center">9.02</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><h1>1143 最长公共子序列</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR </span><br><span class="line">all[&quot;基本概念:&quot;] --&gt; id &amp; id2</span><br><span class="line">id[&quot;子数组/字串:&quot;] --&gt; 连续</span><br><span class="line">id2[&quot;子序列:&quot;] --&gt; 不一定连续</span><br></pre></td></tr></table></figure><p>计算所有公共子序列中的最长长度。<br>在背包问题中，我们的nums数组只有一个，在这里需要处理的子序列为两个。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1723365392755.webp" alt="1723365392755.png"><br>把两个字符串分别叫做 s 和 t ， 长度设为 n 和 m<br>从 s 和 t 的最后一个字母开始考虑，两两组合有4种情况<br>都选和都不选对应的子问题其实一样:因为是最长子序列，所以都选肯定比都不选好</p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1723812520430.webp" alt="1723812520430.png"><br>考虑到是最长子序列，所以简化</p><h2 id="递归代码">递归代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s[i] = t[j]时,不需要考虑只选其中一个的情况</span></span><br><span class="line"><span class="comment"># dfs(i,j) = dfs(i-1, j-1) + 1</span></span><br><span class="line"><span class="comment"># s[i] != t[j]时,不需要考虑都不选的情况</span></span><br><span class="line"><span class="comment"># dfs(i,j) = max(dfs(i-1,j),dfs(i,j-1))</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(text1)</span><br><span class="line">        m = <span class="built_in">len</span>(text2)</span><br><span class="line">        @cache                        <span class="comment"># 记忆化搜索</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> <span class="keyword">or</span> j &lt; <span class="number">0</span>:        <span class="comment"># 边界条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> text1[i] == text2[j]:  <span class="comment"># 可以选</span></span><br><span class="line">                <span class="keyword">return</span> dfs(i-<span class="number">1</span>, j-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:                     <span class="comment"># 不能选</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">1</span>, j), dfs(i, j-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>, m-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>时间复杂度:$O(N*M)$</p><blockquote><p>利用状态个数 * 单个状态的计算时间</p></blockquote><p>空间复杂度:$O(N*M)$</p><h2 id="递推代码">递推代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s[i] = t[j]时， f[i][j] = f[i-1][j-1] + 1</span></span><br><span class="line"><span class="comment"># s[i] != t[j]时，f[i][j] = max(f[i-1][j], f[i][j-1])</span></span><br><span class="line"><span class="comment"># 只移动答案数组，防止出现负数下标；相当于把f[i][j]向右下整体平移一个单位</span></span><br><span class="line"><span class="comment"># s[i] = t[j]时， f[i+1][j+1] = f[i][j] + 1</span></span><br><span class="line"><span class="comment"># s[i] != t[j]时，f[i+1][j+1] = max(f[i][j+1], f[i+1][j])</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(text1)</span><br><span class="line">        m = <span class="built_in">len</span>(text2)</span><br><span class="line">        f = [[<span class="number">0</span>] * (m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]):</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>] = f[i][j] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j+<span class="number">1</span>], f[i+<span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure><p>时间复杂度:$O(N*M)$</p><blockquote><p>利用状态个数 * 单个状态的计算时间</p></blockquote><p>空间复杂度:$O(N*M)$</p><h2 id="优化成两个一维数组">优化成两个一维数组</h2><h2 id="优化成一个一维数组">优化成一个一维数组</h2><p>按空间来算，对于每一个状态：我们只需要知道它的左边($f[i-1][j]$)，上面($f[i][j-1]$)和左上($f[i-1][j-1]$)三个相邻状态。<br>如果只有一个一维数组，那么它左上的状态就会被之前的计算给覆盖掉。需要一个临时变量pre记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s[i] = t[j]时， f[j+1] = f[j] + 1</span></span><br><span class="line"><span class="comment"># s[i] != t[j]时，f[j+1] = max(f[j+1], f[j])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestCommonSubsequence</span>(<span class="params">self, text1: <span class="built_in">str</span>, text2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(text1)</span><br><span class="line">        m = <span class="built_in">len</span>(text2)</span><br><span class="line">        f = [<span class="number">0</span>] * (m+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(text1):</span><br><span class="line">            pre = f[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(text2):</span><br><span class="line">                tmp = f[j+<span class="number">1</span>]         <span class="comment"># f[i+1][j+1]</span></span><br><span class="line">                <span class="keyword">if</span> x == y:</span><br><span class="line">                    f[j+<span class="number">1</span>] = pre + <span class="number">1</span>  <span class="comment"># pre = f[i][j+1]</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[j+<span class="number">1</span>] = <span class="built_in">max</span>(f[j+<span class="number">1</span>], f[j])</span><br><span class="line">                pre = tmp</span><br><span class="line">        <span class="keyword">return</span> f[m]</span><br></pre></td></tr></table></figure><p>时间复杂度:$O(N*M)$</p><blockquote><p>利用状态个数 * 单个状态的计算时间</p></blockquote><p>空间复杂度:$O(M)$</p><h1>72 编辑距离</h1><p>s = horse  i<br>t = ros       j<br>当 s[i] = t[j]时，直接去掉这两个字符，不用采用任何操作。 dfs(i-1, j-1)<br>当 s[i] != t[j]时，可以采用以下操作中的一种：</p><ol><li>删除一个字符 : 从 s 中删除 dfs(i - 1,  j)</li><li>插入一个字符 : 插入的肯定是 t[j] , 插入后为dfs(i+1,j) 同时去掉最后一位得到 dfs(i, j - 1)</li><li>替换一个字符 : 把s[i]的字符替换为和t[j]相同的，然后同时去掉最后一位得到 dfs(i-1, j-1)</li></ol><p>边界条件:</p><ol><li>如果 word1 没有字符，把word1 变为 word2 需要 第二个字符的长度步  ,下标为 0 - j 的字符串长度为 j + 1</li><li>如果 word2 没有字符，把word1 变为 word2 需要删除 i + 1 步</li></ol><h2 id="递归">递归</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1724001921192.webp" alt="1724001921192.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word1)</span><br><span class="line">        m = <span class="built_in">len</span>(word2)</span><br><span class="line">        @cache</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, j</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> word1[i] == word2[j]:</span><br><span class="line">                <span class="keyword">return</span> dfs(i-<span class="number">1</span>, j-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(dfs(i-<span class="number">1</span>,j), dfs(i, j-<span class="number">1</span>), dfs(i-<span class="number">1</span>, j-<span class="number">1</span>)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>, m-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>时间复杂度:$O(N*M)$</p><blockquote><p>利用状态个数 * 单个状态的计算时间</p></blockquote><p>空间复杂度:$O(N*M)$</p><h2 id="递推">递推</h2><blockquote><p>需要特别注意边界问题</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s[i] = t[j], f[i][j] = f[i-1][j-1] </span></span><br><span class="line"><span class="comment"># s[i] != t[j], f[i][j] = min(f[i-1][j], f[i][j-1], f[i-1][j-1]) +  1</span></span><br><span class="line"><span class="comment"># 变换</span></span><br><span class="line"><span class="comment"># s[i] = t[j], f[i+1][j+1] = f[i][j] </span></span><br><span class="line"><span class="comment"># s[i] != t[j], f[i+1][j+1] = min(f[i][j+1], f[i+1][j], f[i][j]) +  1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDistance</span>(<span class="params">self, word1: <span class="built_in">str</span>, word2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(word1)</span><br><span class="line">        m = <span class="built_in">len</span>(word2)</span><br><span class="line">        f = [ [<span class="number">0</span>]*(m+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 初始化 i = 0 和 j = 0 的情况</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="built_in">list</span>(<span class="built_in">range</span>(m + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(word1):</span><br><span class="line">            f[i + <span class="number">1</span>][<span class="number">0</span>] = i + <span class="number">1</span>      <span class="comment"># 注意 下标 i+1</span></span><br><span class="line">            <span class="keyword">for</span> j, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(word2):</span><br><span class="line">                <span class="keyword">if</span> x == y:</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>] = f[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="built_in">min</span>(f[i][j+<span class="number">1</span>], f[i+<span class="number">1</span>][j], f[i][j]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure><h2 id="优化空间">优化空间</h2><h1>300 最长递增子序列</h1><p>子序列： 从数组中选择一些数，且顺序和数组中的顺序是一致的<br>$O(n^2)$：回溯–&gt;记忆化搜索–&gt;递推<br>$O(nlogn)$：二分 + 贪心</p><ol><li>子序列本质上是数组的一个子集，用子集型回溯，选或不选考虑。为了比较大小，需要知道上一个选的数字。</li><li>枚举选哪个 ： 比较当前选的数字和下一个要选的数字。从后往前，直接枚举比最后一个数字小的数字  只需要一个下标</li></ol><h2 id="递归-2">递归</h2><p>状态: dfs(i) 表示以 nums[i] 结尾的最长LIS<br>状态转移 方程：<br>nums[j] &lt; nums[i] dfs(i) = max(dfs(j)) + 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        @cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> :               <span class="comment"># 边界条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    cnt = <span class="built_in">max</span>(dfs(j), cnt)</span><br><span class="line">            <span class="keyword">return</span> cnt + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans = <span class="built_in">max</span>(dfs(i), ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度">复杂度</h3><ol><li>计算公式：状态个数 乘上 单个状态所需要的计算时间<br>状态个数为$O(n)$，遍历以哪个元素结尾的最大长度需要O(n)时间，总的时间复杂度为$O(N^2)$</li><li>空间复杂度为$O(n)$。</li></ol><h3 id="优化空间-2">优化空间</h3><h2 id="递推-2">递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 递归 dfs(i) = max(dfs(j)) + 1</span></span><br><span class="line">        <span class="comment"># 递推 f[i] = max(f[j]) + 1</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f = [<span class="number">0</span>] * n</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                <span class="keyword">if</span> nums[j] &lt; nums[i]:</span><br><span class="line">                    cnt = <span class="built_in">max</span>(f[j], cnt)</span><br><span class="line">            f[i] = cnt + <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># for i in range(n):</span></span><br><span class="line">        <span class="comment">#     ans =  max(ans, f[i])</span></span><br><span class="line">        <span class="comment"># return ans</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f)</span><br></pre></td></tr></table></figure><h2 id="转换为最长公共子序列">转换为最长公共子序列</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725265307203.webp" alt="1725265307203.png"></p><h2 id="交换状态与状态值">交换状态与状态值</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725265545634.webp" alt="1725265545634.png"><br>没有重叠子问题，不能叫做动态规划，变为贪心<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725265829465.webp" alt="1725265829465.png"></p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1725266131702.webp" alt="1725266131702.png"></p><h3 id="算法思想">算法思想</h3><p>在$g$上用<strong>二分查找</strong>快速找到第一个$&gt;=num[i]$的下标$j$。如果$j$不存在，那么$nums[i]$直接加到$g$末尾;<br>否则修改$g[j]$为$nums[i]$。<br>这个算法属于贪心 + 二分。</p><h3 id="代码">代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动实现二分</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bisect_left</span>(<span class="params">g, x</span>):</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(g)  <span class="comment"># [ )</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid =  (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt;= g[mid]:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left  </span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 二分 + 贪心</span></span><br><span class="line">        g = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            j = bisect_left(g, x)  <span class="comment"># g 中第一个大于x的位置</span></span><br><span class="line">            <span class="keyword">if</span> j == <span class="built_in">len</span>(g):</span><br><span class="line">                <span class="comment"># j 不存在</span></span><br><span class="line">                g.append(x)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                g[j] = x</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(g)</span><br></pre></td></tr></table></figure><p>把 nums 当成 g 数组， 优化额外空间为 O(1)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bisect_left1</span>(<span class="params">g, x, left, right</span>):</span><br><span class="line">    <span class="comment"># left, right = 0, len(g)  # [ )</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        mid =  (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> x &lt;= g[mid]:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLIS</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 二分 + 贪心</span></span><br><span class="line">        ng = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            j = bisect_left1(nums, x, <span class="number">0</span>, ng)</span><br><span class="line">            <span class="keyword">if</span> j == ng:</span><br><span class="line">                <span class="comment"># j 不存在</span></span><br><span class="line">                nums[ng] = x</span><br><span class="line">                ng += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[j] = x</span><br><span class="line">        <span class="keyword">return</span> ng</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP动态规划--背包问题</title>
      <link href="/posts/53fcf002.html"/>
      <url>/posts/53fcf002.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th>AC3</th></tr></thead><tbody><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/house-robber/description/?envType=study-plan-v2&amp;envId=top-100-liked">198 打家劫舍 </a></td><td style="text-align:center">medium</td><td style="text-align:center">DP(选 or 不选)</td><td style="text-align:center">7.29</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/target-sum/">494 目标和</a></td><td style="text-align:center">medium</td><td style="text-align:center">0-1背包</td><td style="text-align:center">7.29</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/coin-change/">322 零钱兑换</a></td><td style="text-align:center">medium</td><td style="text-align:center">完全背包</td><td style="text-align:center">7.29</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/climbing-stairs/">70 爬楼梯</a></td><td style="text-align:center">easy</td><td style="text-align:center">DP</td><td style="text-align:center">7.29</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746 使用最小花费爬楼梯</a></td><td style="text-align:center">easy<br></td><td style="text-align:center">DP</td><td style="text-align:center">7.29</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/combination-sum-iv/">377 组合总和 Ⅳ</a></td><td style="text-align:center">medium</td><td style="text-align:center">DP(爬楼梯改进)</td><td style="text-align:center">7.30</td><td style="text-align:center"></td><td>以为是背包问题，结果是爬楼梯</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466 统计构造好字符串的方案数</a></td><td style="text-align:center">medium</td><td style="text-align:center">DP(爬楼梯改进)</td><td style="text-align:center">7.30</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/count-number-of-texts/">2266 统计打字方案数</a></td><td style="text-align:center">medium</td><td style="text-align:center">线性DP</td><td style="text-align:center"></td><td style="text-align:center"></td><td>还不会(下个blog解)</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/delete-and-earn/">740 删除并获得点数</a></td><td style="text-align:center">medium</td><td style="text-align:center">打家劫舍变形</td><td style="text-align:center">7.30</td><td style="text-align:center"></td><td>巧妙</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/house-robber-ii/">213 打家劫舍 II</a></td><td style="text-align:center">medium</td><td style="text-align:center">打家劫舍变形</td><td style="text-align:center">7.30</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">LCR 166</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/length-of-the-longest-subsequence-that-sums-to-target/">2915 和为目标值的最长子序列的长度</a></td><td style="text-align:center">medium</td><td style="text-align:center">0-1背包</td><td style="text-align:center">7.31</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">416</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/">2787 将一个数字表示成幂的和的方案数</a></td><td style="text-align:center">medium</td><td style="text-align:center">0-1背包</td><td style="text-align:center">7.29</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/coin-change-ii/">518 零钱兑换 II</a></td><td style="text-align:center">medium</td><td style="text-align:center">完全背包</td><td style="text-align:center">7.29</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/perfect-squares/">279 完全平方数</a></td><td style="text-align:center">medium</td><td style="text-align:center">完全背包</td><td style="text-align:center">7.29</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><h1>DP基本思想</h1><p>动态规划的核心就是状态定义和状态转移方程。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721898220103.webp" alt="1721898220103.png"></p><h2 id="0-1-背包">0-1 背包</h2><h3 id="基础模板">基础模板</h3><p>0-1背包和完全背包都是非常重要的DP模型，是[选 or 不选]这个思想的代表。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722077635307.webp" alt="1722077635307.png"></p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722077828060.webp" alt="1722077828060.png"><br>状态转移函数:<br>容量c作为参数传入dfs，return的是最大价值和<br>不选：容量c不变，最大价值不变；选：容量c减少，价值增加<br>$$dfs(i,c) = max(  dfs(i-1,c),  dfs(i-1,c-w[i])+v[i])  $$<br>基本代码模板:<br><strong>递归版本:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">zero_one_knapsack</span>(<span class="params">capacity: <span class="built_in">int</span>, w: <span class="type">List</span>[<span class="built_in">int</span>], v: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt;<span class="built_in">int</span>:</span><br><span class="line">    n = <span class="built_in">len</span>(w)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, c</span>):      <span class="comment"># c为剩余容量</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:       <span class="comment"># 此时一个物品都没有了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> c &lt; w[i]:    <span class="comment"># 如果i物品的体积 &gt; 剩余背包容量  --&gt; 不选</span></span><br><span class="line">            <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则 --&gt; 选 or 不选</span></span><br><span class="line">        res =  <span class="built_in">max</span>(dfs(i-<span class="number">1</span>, c), dfs(i-<span class="number">1</span>, c-w[i]) + v[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dfs(n-<span class="number">1</span>, capacity)  <span class="comment"># 从最后一个物品开始</span></span><br></pre></td></tr></table></figure><p><strong>记忆化搜索：</strong><br>@cache 或者数组，这里有两个参数，需要一个二维数组实现</p><h3 id="常见变形">常见变形</h3><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722079721999.webp" alt="1722079721999.png"></p><h2 id="完全背包">完全背包</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722236426662.webp" alt="1722236426662.png"></p><p>和0-1背包的区别：完全背包中，在选完一个物品之后，i 是不变的，因为可以重复选</p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722240512395.webp" alt="1722240512395.png"></p><h3 id="常见变形-2">常见变形</h3><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722240573299.webp" alt="1722240573299.png"></p><h1>边界总结</h1><p>不同的题目，所要的答案不同， 比如：方案数，最大、小值，数字个数，能否构成？<br>这也就意味着 dp 数组值可以为数值，也可以是 boolean 类型<br>另外，同样是数值的情况下，不同的要求，也会造成不同的初始值 f【0】【0】：</p><ol><li>能否构成： f【0】【0】 = True 0 可以构成 0</li><li>方案数： f【0】【0】 = 1 0 组成 0 只有一种方案</li><li>数字个数： f【0】【0】 = 0 0 组成 0 没有使用数字</li><li>最大、小值： 问题一般会回归到 方案数 或 数字个数问题， 一般会使用到 max/min 函数约束答案，而且会使用 ±inf 初始化来表示极端情况。 比如：力扣 279 求最小数量<br>总结一下边界</li></ol><ul><li>求max/min的模型里：</li><li>求体积<code>恰好</code>为j：</li><li>求max, f = 【0】+【-inf】* t</li><li>求min, f = 【0】+【inf】* t</li><li>最终f【j】代表体积恰好为j时的价值极值。</li></ul><hr><ul><li>求体积<code>至多</code>为j时:</li><li>f【0】 = 【0】+【0】* t (max/min)</li><li>最终f【j】代表体积<code>至多</code>为j时的价值极值</li></ul><hr><ul><li>求体积<code>至少</code>为j时:</li><li>f【0】 = 【0】+【0】* t (max/min)</li><li>同时遍历体积需要修改循环下界v-&gt;0、转移需要修改为从max(0,j-v),即</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.vol, -<span class="number">1</span>, -<span class="number">1</span>):f【j】 = merge(f【j】, f【<span class="built_in">max</span>(j - v,<span class="number">0</span>)】 + w) <span class="comment"># 01背包</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.vol+<span class="number">1</span>):f【j】 = merge(f【j】, f【<span class="built_in">max</span>(j - v,<span class="number">0</span>)】 + w) <span class="comment"># 完全背包</span></span><br></pre></td></tr></table></figure><ul><li>最终f【j】代表体积<code>至少</code>为j时的价值极值</li></ul><hr><ul><li>求方案数的模型里（一般要取模）:</li><li>求体积<code>恰好</code>为j：</li><li>求max, f = 【1】+【0】* t</li><li>最终f【j】代表体积恰好为j时的方案数。</li></ul><hr><ul><li>求体积<code>至多</code>为j时:</li><li>f = 【1】+【1】* t</li><li>最终f【j】代表体积<code>至多</code>为j时的方案数。</li></ul><hr><ul><li>求体积<code>至少</code>为j时:</li><li>f = 【1】+【0】* t</li><li>同时遍历体积需要修改循环下界v-&gt;0、转移需要修改为从max(0,j-v),即</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.vol, -<span class="number">1</span>, -<span class="number">1</span>):f【j】 += f【<span class="built_in">max</span>(j - v,<span class="number">0</span>)】 <span class="comment"># 01背包</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.vol+<span class="number">1</span>):f【j】 += f【<span class="built_in">max</span>(j - v,<span class="number">0</span>)】 <span class="comment"># 完全背包</span></span><br></pre></td></tr></table></figure><ul><li>最终f【j】代表体积<code>至多少</code>为j时的方案数</li></ul><h1>198 打家劫舍</h1><h2 id="递归">递归</h2><p>把一个大问题变成规模更小的子问题：从第一个房子或者最后一个房子开始思考是较容易的，因为他们收到的约束最小。<br>考虑<strong>最后一个房子</strong> 选 or 不选。如果不选：变成 n-1 个房子的问题；如果选：变成 n-2 个房子的问题。（由于选的情况下，相邻的房子不能选）<br>得到以下搜索树：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722069742113.webp" alt="1722069742113.png|400"><br>状态转移方程如下：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722069798748.webp" alt="1722069798748.png|400"><br>在定义DFS或者DP数组中，他只能表示从一些元素中算出的结果，而不是从一个元素中算出的结果。<br><strong>没有把得到的金额作为递归的入参，而是把他当作了返回值。</strong>(和后面写记忆化有关)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 从最后一个房子开始</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>   <span class="comment"># 最高金额为0</span></span><br><span class="line">            res = <span class="built_in">max</span>(dfs(i-<span class="number">1</span>), dfs(i-<span class="number">2</span>) + nums[i])</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>由于回溯的时间复杂度是指数级别的,这样写会超时。</p><h2 id="记忆化搜索">记忆化搜索</h2><p>目的：优化时间复杂度<br>在下面的搜索树中，计算了两次dfs(2),可以把结果存到一个cache数组或者哈希表中。在第二次算的时候，就可以直接返回cache里面保存的结果了。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722070711672.webp" alt="1722070711672.png|400"><br>优化后的搜索树为：只有$O(n)$个节点，因此时间复杂度从指数级别优化到了$O(n)$<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722071406170.webp" alt="1722071406170.png|500"><br>Python:可以用@cache 做：它的原理是用一个hashmap记录入参和对应的返回值。也可以用数组实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        cache = [-<span class="number">1</span>] * n    </span><br><span class="line">        <span class="comment"># 从最后一个房子开始</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>     <span class="comment"># 最高金额为0</span></span><br><span class="line">            <span class="keyword">if</span> cache[i] != -<span class="number">1</span> : <span class="comment"># i已经被计算过</span></span><br><span class="line">                <span class="keyword">return</span> cache[i]</span><br><span class="line">            res = <span class="built_in">max</span>(dfs(i-<span class="number">1</span>), dfs(i-<span class="number">2</span>) + nums[i])</span><br><span class="line">            cache[i] = res   <span class="comment"># 更新记忆数组</span></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="时间复杂度">时间复杂度</h3><p>计算公式：状态个数 乘上 单个状态所需要的计算时间<br>本题中,状态个数为$O(n)$的，单个状态的计算时间是$O(1)$的，所以时间复杂度是$O(n)$的<br>空间复杂度:$O(n)$， 因为用了记忆化数组 cache[n]</p><h2 id="递推">递推</h2><p>目的：空间复杂度优化到$O(1)$<br>计算max，发生在dfs调用结束之后，在递归的归的过程中，才发生了实际的计算。<br>有记忆化搜索树可知，0和1归到2，2和1归到3,因为知道如何归，可以去掉递归中的递，只剩下归的过程。<strong>直接从树的最下面开始，往上计算</strong>。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722072139948.webp" alt="1722072139948.png|600"></p><p>需要对$i=0$和$i=1$的情况做特殊处理，因为在更新$f$时会产生复数下标。<br>$f[i]$表示前$i$个房子得到的maxMoney<br>x 表示 Nums[i]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">2</span>)     <span class="comment"># 防止i - 2数组越界</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            f[i + <span class="number">2</span>] = <span class="built_in">max</span>(f[i + <span class="number">1</span>], f[i] + x)</span><br><span class="line">        <span class="keyword">return</span> f[n + <span class="number">1</span>]    <span class="comment"># (n - 1) + 2</span></span><br></pre></td></tr></table></figure><p>这个代码的空间复杂度仍然是$O(n)$的</p><h3 id="空间复杂度优化">空间复杂度优化</h3><p>要计算f[i]，只需其上一个状态和上上一个状态。何时更新这两个状态，如何更新？<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722076253155.webp" alt="1722076253155.png"><br>$$f[i] = max(f[i-1], f[i-2]+nums[i])$$<br>对于f[i+1]来说，其上一个状态为$f1 = f[i]$($newf = f[i]$)，上上一个状态 $f0 = f[i-1]$ (f1 = f[i-1])<br>所以更新 f0 = f1，f1 = newf</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f0, f1 = <span class="number">0</span>, <span class="number">0</span>     <span class="comment"># i-2 和 i-1</span></span><br><span class="line">        newf = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            newf = <span class="built_in">max</span>(f1, f0 + x)</span><br><span class="line">            f0 = f1       <span class="comment"># 更新历史状态，滚动数组</span></span><br><span class="line">            f1 = newf</span><br><span class="line">        <span class="keyword">return</span> newf</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(n)$，空间复杂度为$O(1)$</p><h1>494 目标和</h1><p>假设添加正好的数的和为p, 那么添加负数的就是所有元素的和 s 减去 p ,  所以$$target = p - (s-p)$$<br>化简得到 ： $2*p = s + target$ 则$p = (s + target)/2$<br>题目变成，从nums中选择一些数字(和为p)，且正好满足上面的公式。<br>边界条件： s + t 为非负数，且为偶数<br>选一些数，这些数的和 p，恰好等于一个数(s + target) / 2的方案数<br>这里的(s + target) / 2 就是我们需要的背包容量 capacity</p><h2 id="加法原理">加法原理</h2><p>做一件事有两种方式，方案数就是这两种方式的方案之和<br>s 已知，target已知，能够求出 capacity<br>$$dfs(i,c) = dfs(i-1,c) + dfs(i-1,c-nums[i])$$</p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722079976893.webp" alt="1722079976893.png"></p><h2 id="记忆化搜索-2">记忆化搜索</h2><h3 id="cache">@cache</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        target += <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 如果s + t 是负数，或者计数，则没有合法答案</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span> <span class="keyword">or</span> target % <span class="number">2</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        target /= <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        @ cache</span><br><span class="line">        <span class="comment"># 不加cache 执行用时为9685ms；加了用时为148ms</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, c</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> :   <span class="comment"># 所有的数字前都需要+正负号</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> c == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> c &lt; nums[i]: <span class="comment"># 只能不选</span></span><br><span class="line">                <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c)</span><br><span class="line">            res = dfs(i-<span class="number">1</span>, c) + dfs(i-<span class="number">1</span>, c-nums[i])</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>, target)</span><br></pre></td></tr></table></figure><h3 id="记忆数组">记忆数组</h3><p>需要用一个二维数组表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        target += <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 如果s + t 是负数，或者计数，则没有合法答案</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span> <span class="keyword">or</span> target % <span class="number">2</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># target = int(target / 2)</span></span><br><span class="line">        target //= <span class="number">2</span> </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># @ cache</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 选第i个数字前面加正号</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, c</span>):  <span class="comment"># （n, target）</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> :   <span class="comment"># 所有的数字前都需要+正负号</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> c == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> dp[i][c] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> dp[i][c]</span><br><span class="line">            <span class="keyword">if</span> c &lt; nums[i]: <span class="comment"># 只能不选</span></span><br><span class="line">                <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c)</span><br><span class="line">                </span><br><span class="line">            res = dfs(i-<span class="number">1</span>, c) + dfs(i-<span class="number">1</span>, c-nums[i])</span><br><span class="line">            dp[i][c] = res</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>, target)</span><br></pre></td></tr></table></figure><h2 id="递推-2">递推</h2><p>dfs —&gt; 变为 f 数组<br>$$dfs(i,c)= dfs(i-1,c) + dfs(i-1,c-nums[i])$$<br>$$f[i][c] = f[i-1][c] + f[i-1][c-nums]$$<br>+1<br>$$f[i+1][c] = f[i][c] + f[i][c-nums]$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行时间直接降到了74ms</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        target += <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 如果s + t 是负数，或者计数，则没有合法答案</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span> <span class="keyword">or</span> target % <span class="number">2</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        target //= <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [ [<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 如何初始化?</span></span><br><span class="line">        <span class="comment"># 由于数组下标都+1, i=0, c=0 时初始值为1 (由边界条件得到)</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># f[i][c] = f[i-1][c] + f[i-1][c-nums] 需要给定f[0][0]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># (0,n)   # 对于数组中的第i个数字</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):  </span><br><span class="line">                <span class="keyword">if</span> c &lt; nums[i]:</span><br><span class="line">                    dp[i+<span class="number">1</span>][c] = dp[i][c]<span class="comment"># 不选</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i+<span class="number">1</span>][c] = dp[i][c] + dp[i][c-nums[i]] <span class="comment"># 选</span></span><br><span class="line">        <span class="keyword">return</span> dp[n][target]</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度: $O(n * sum(nums))$<br>空间复杂度: $O(n * target) = O(n * sum(nums))$</p></blockquote><h3 id="优化1-滚动数组">优化1: 滚动数组</h3><p>每次把$f[i+1]$计算完之后，后面就不会用到$f[i]$了<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722231766589.webp" alt="1722231766589.png"><br>将空间复杂度优化到了$O(target)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">len</span>(nums)</span><br><span class="line">dp = [ [<span class="number">0</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f[i][c] = f[i-1][c] + f[i-1][c-nums] 需要给定f[0][0]</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># (0,n)   # 对于数组中的第i个数字</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(target+<span class="number">1</span>):  </span><br><span class="line"><span class="keyword">if</span> c &lt; nums[i]:</span><br><span class="line">dp[(i+<span class="number">1</span>) % <span class="number">2</span>][c] = dp[i % <span class="number">2</span>][c]<span class="comment"># 不选</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">dp[(i+<span class="number">1</span>) % <span class="number">2</span>][c] = dp[i % <span class="number">2</span>][c] + dp[i % <span class="number">2</span>][c-nums[i]]</span><br></pre></td></tr></table></figure><h3 id="优化2：单数组">优化2：单数组</h3><p>从后往前算，不会覆盖掉。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722235797289.webp" alt="1722235797289.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTargetSumWays</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        target += <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="comment"># 如果s + t 是负数，或者计数，则没有合法答案</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span> <span class="keyword">or</span> target % <span class="number">2</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        target //= <span class="number">2</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        dp = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 倒着枚举 target</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="comment"># range(10, 4, -1) 包含起点，但不包含终点 10, 9, 8, 7, 6, 5</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(target, x-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> c &gt;= nums[i]:</span><br><span class="line">                    dp[c] = dp[c] + dp[c - x]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure><h3 id="变形">变形</h3><p>至多为target:</p><ol><li>return 1 if c == 0 else 0 改为 return 1</li><li>上面的 f 数组全部初始化为 1</li><li>能递归到终点说明 c&gt;=0</li><li>因为 dfs(-1,c) 都是 1，翻译成递推就是$f[0][c] = 1$<br>至少为target:</li><li>return 1 if c &lt;= 0 else 0 改为 return 1</li><li>循环到0</li><li>把所有$c&lt;=0$的状态记录到$f[0]$里面去。</li><li>f[0] 表示至少为 0 的方案数，也就表示没有任何约束。比如选第 i 个物品后 c&lt;=0 了，就表示前面的 i-1 个物品可以不受约束地随意选或不选了。</li><li>若$target = 0$，至少为target，此时每个物品都可以选或者不选，一共有 $2^n$ 种方案，下面的写法可以算出 $2^n$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(target, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line"><span class="keyword">if</span> c &gt;= nums[i]:</span><br><span class="line">dp[c] = dp[c] + dp[<span class="built_in">max</span>(c - x, <span class="number">0</span>)]</span><br></pre></td></tr></table></figure><h1>322 零钱兑换</h1><h2 id="回溯">回溯</h2><p>注意：这里选$i$的化可以选多个，所以仍然是dfs(i)<br>$$dfs(i,t) = min(dfs(i-1,t),dfs(i,t-nums[i])+1)$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        <span class="comment"># res = inf</span></span><br><span class="line">        </span><br><span class="line">        @ cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, t</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span> :</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> t == <span class="number">0</span> <span class="keyword">else</span> inf <span class="comment"># inf表示不合法的方案</span></span><br><span class="line">            <span class="keyword">if</span> t &lt; coins[i]:</span><br><span class="line">                <span class="keyword">return</span> dfs(i-<span class="number">1</span>, t) <span class="comment"># 不选</span></span><br><span class="line">            res = <span class="built_in">min</span>(dfs(i-<span class="number">1</span>, t), dfs(i, t-coins[i]) + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">        ans = dfs(n-<span class="number">1</span>, amount)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; inf <span class="keyword">else</span> -<span class="number">1</span>      <span class="comment"># inf 不合法</span></span><br></pre></td></tr></table></figure><h2 id="递推-3">递推</h2><p>$$dfs(i,t) = min(dfs(i-1,t),dfs(i,t-nums[i])+1)$$<br>改成 f：<br>$$f[i][t] = min(f[i-1][t], f[i][t-nums[i]] + 1)$$<br>$$f[i+1][t] = min(f[i][t], f[i+1][t-nums[i]] + 1)$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[inf] * (amount + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(coins):</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>): <span class="comment"># 需要包含amount</span></span><br><span class="line">                <span class="keyword">if</span> t &lt; x:</span><br><span class="line">                    dp[i+<span class="number">1</span>][t] = dp[i][t] <span class="comment"># 不选</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i+<span class="number">1</span>][t] = <span class="built_in">min</span>(dp[i][t], dp[i+<span class="number">1</span>][t-x] + <span class="number">1</span>)</span><br><span class="line">        ans = dp[n][amount]  <span class="comment"># 这里返回(n-1) + 1 = n</span></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; inf <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="单数组递推">单数组递推</h2><p>$$f[i][t] = min(f[i-1][t], f[i][t-nums[i]] + 1)$$<br>$$f[t] = min(f[t],f[t-x]+1)$$<br>对于 amount 从后往前处理。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722242018116.webp" alt="1722242018116.png"><br>这里正序计算是对的<br>看后半部分，计算 i 时，从前面转移过来的也是i<br>就是先改了前面的数，再去算后面的数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">coinChange</span>(<span class="params">self, coins: <span class="type">List</span>[<span class="built_in">int</span>], amount: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        <span class="comment"># res = inf</span></span><br><span class="line">        dp = [inf] * (amount + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># i=0, c=0才是0，其他都是无穷大</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(coins):</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>): <span class="comment"># 需要包含amount和x</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> t &lt; x:</span><br><span class="line">                    dp[t] = dp[t]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[t] = <span class="built_in">min</span>(dp[t], dp[t-x] + <span class="number">1</span>)</span><br><span class="line">        ans = dp[amount]  <span class="comment"># 这里返回(n-1)</span></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt; inf <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>空间复杂度优化到了$O(amount)$</p><h2 id="循环顺序问题">循环顺序问题</h2><p>对于下面的状态转移方程：<br>$$f[i+1][t] = min(f[i][t], f[i+1][t-w[i]] + v[i])$$<br>改写为：<br>$$f[t] = min(f[t],f[t-w[i]]+v[i])$$<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1722242938656.webp" alt="1722242938656.png"></p><hr><p>w &gt; 0，如果用到的是f[c+w]或者f[c]本身，那就是后面的数据先被用后更新，就是正序遍历<br>w &gt; 0, 如果用到的是f[c-w]，那就是前面的数据先被用后更新，就是倒序遍历</p><h1>518 零钱兑换 II</h1><h2 id="回溯-2">回溯</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 组合数：加法原理</span></span><br><span class="line">        <span class="comment"># dfs(i,c) = dfs(i-1,c) + dfs(i,c-x)</span></span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        @ cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, c</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> c==<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> c &lt; coins[i]:</span><br><span class="line">                <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c) <span class="comment"># 不选</span></span><br><span class="line">            <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c) + dfs(i, c-coins[i])</span><br><span class="line">            </span><br><span class="line">        ans = dfs(n-<span class="number">1</span>, amount)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="递推-4">递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dfs(i,c) = dfs(i-1,c) + dfs(i,c-x)</span></span><br><span class="line">        <span class="comment"># f[i][c] = f[i-1][c] + f[i][c-x]</span></span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        <span class="comment"># f[i+1][c] = f[i][c] + f[i+1][c-x]</span></span><br><span class="line"></span><br><span class="line">        f = [[<span class="number">0</span>] * (amount+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 由边界条件 ：return 1 if c==0 else 0</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(coins):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> c &lt; x:       <span class="comment"># 不选</span></span><br><span class="line">                    f[i+<span class="number">1</span>][c] = f[i][c]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i+<span class="number">1</span>][c] = f[i][c] + f[i+<span class="number">1</span>][c-x]</span><br><span class="line">        <span class="keyword">return</span> f[n][amount]</span><br></pre></td></tr></table></figure><h3 id="优化">优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount: <span class="built_in">int</span>, coins: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># f[i][c] = f[i-1][c] + f[i][c-x]</span></span><br><span class="line">        <span class="comment"># f[c] = f[c] + f[c-x]  正序</span></span><br><span class="line"></span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        f = [<span class="number">0</span>] * (amount+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 由边界条件 ：return 1 if c==0 else 0</span></span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(coins):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(x, amount + <span class="number">1</span>):</span><br><span class="line">               f[c] = f[c] + f[c-x]</span><br><span class="line">        <span class="keyword">return</span> f[amount]</span><br></pre></td></tr></table></figure><h1>70 爬楼梯</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">1</span>] * (n + <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> n - i &lt; <span class="number">2</span>:   <span class="comment"># 不够2步</span></span><br><span class="line">                dp[i+<span class="number">2</span>] = dp[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i+<span class="number">2</span>] = dp[i+<span class="number">1</span>] + dp[i]</span><br><span class="line">        <span class="keyword">return</span> dp[n+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1>279 完全平方数</h1><p>选 i 可以重复选<br>$$f[i][t] = min(f[i-1][t],f[i][t - x] + 1)$$<br>$$f[i+1][t] = min(f[i][t],f[i+1][t-x] + 1)$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 最少数量</span></span><br><span class="line">        nums = []</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i*i &lt;= n:</span><br><span class="line">            nums.append(i * i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        dp = [ [inf] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> t &lt; x: <span class="comment"># 不选</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][t] = dp[i][t]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i+<span class="number">1</span>][t] = <span class="built_in">min</span>(dp[i][t], dp[i+<span class="number">1</span>][t - x] + <span class="number">1</span>)</span><br><span class="line">        ans = dp[length][n]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="单数组优化">单数组优化</h2><p>$$f[i][t] = min(f[i-1][t],f[i][t] + 1)$$<br>改为:<br>$$f[t] = min(f[t],f[t - x]+1)$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSquares</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = []</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i*i &lt;= n:</span><br><span class="line">            nums.append(i * i)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        f = [inf] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(x, n + <span class="number">1</span>): <span class="comment"># 正序，含x-n</span></span><br><span class="line">                f[t] = <span class="built_in">min</span>(f[t],f[t-x] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><h1>764 使用最小花费爬楼梯</h1><p>要注意 cost 数组不能越界。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dfs(i) = min(dfs(i-1), dfs(i-2))</span></span><br><span class="line">        <span class="comment"># f[i] = min(f[i-1] + cost[i-1], f[i-2] + cost[i-2])</span></span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">2</span>)  <span class="comment"># 最低花费</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):  </span><br><span class="line">            f[i] = <span class="built_in">min</span>(f[i-<span class="number">1</span>] + cost[i-<span class="number">1</span>], f[i-<span class="number">2</span>] + cost[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure><h1>2787 将一个数字表示成幂的和的方案数</h1><h2 id="回溯-3">回溯</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, n: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> i ** x &lt;= n:</span><br><span class="line">            nums.append(i ** x)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        @ cache</span><br><span class="line">        <span class="comment"># dfs(i, n) = dfs(i-1, n) + dfs(i-1, n-nums[i])</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, c</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> c == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> c &lt; nums[i]:</span><br><span class="line">                <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c)  <span class="comment"># 不选</span></span><br><span class="line">            <span class="keyword">return</span> dfs(i-<span class="number">1</span>, c) + dfs(i-<span class="number">1</span>, c-nums[i])</span><br><span class="line">        ans = dfs(l-<span class="number">1</span>, n) % (<span class="number">10</span>**<span class="number">9</span> + <span class="number">7</span> )</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="递推-5">递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, n: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> i ** x &lt;= n:</span><br><span class="line">            nums.append(i ** x)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs(i, n) = dfs(i-1, n) + dfs(i-1, n-nums[i])</span></span><br><span class="line">        <span class="comment"># f[i][n] = f[i-1][n] + f[i-1][n-x]</span></span><br><span class="line">        f = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(l + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 边界</span></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> c &lt; x:</span><br><span class="line">                    f[i+<span class="number">1</span>][c] = f[i][c]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i+<span class="number">1</span>][c] = f[i][c] + f[i][c-x]</span><br><span class="line">        <span class="keyword">return</span> f[l][n] % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h3 id="优化-2">优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numberOfWays</span>(<span class="params">self, n: <span class="built_in">int</span>, x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> i ** x &lt;= n:</span><br><span class="line">            nums.append(i ** x)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        l = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># dfs(i, n) = dfs(i-1, n) + dfs(i-1, n-nums[i])</span></span><br><span class="line">        <span class="comment"># f[i][n] = f[i-1][n] + f[i-1][n-x]</span></span><br><span class="line">        <span class="comment"># 倒序 f[c] = f[c] + f[c-x]</span></span><br><span class="line"></span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>         <span class="comment"># 边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n, x-<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 倒序</span></span><br><span class="line">                f[c] = f[c] + f[c-x]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n] % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h1>377 组合总和 Ⅳ</h1><p>以为是背包问题，结果是爬楼梯</p><h2 id="回溯-4">回溯</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 不同数</span></span><br><span class="line">        <span class="comment"># dfs(t) = dfs(t-nums[0]) + ...</span></span><br><span class="line">        <span class="comment"># f[t] = f[t - nums[i]]</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        @ cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="comment"># 加到需要的数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(dfs(i - x) <span class="keyword">for</span> x <span class="keyword">in</span> nums <span class="keyword">if</span> x &lt;= i)</span><br><span class="line">        <span class="keyword">return</span> dfs(target)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dfs(t) = dfs(t-nums[0]) + ...</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        @ cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="comment"># 加到需要的数</span></span><br><span class="line"></span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> x &lt;= i:</span><br><span class="line">                    ans += dfs(i - x)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">            <span class="comment"># return sum(dfs(i - x) for x in nums if x &lt;= i)</span></span><br><span class="line">        <span class="keyword">return</span> dfs(target)</span><br></pre></td></tr></table></figure><h2 id="递推-6">递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 不同数</span></span><br><span class="line">        <span class="comment"># dfs(t) = dfs(t-nums[0]) + ...</span></span><br><span class="line">        <span class="comment"># f[t] = f[t - nums[i]]</span></span><br><span class="line">        f = [<span class="number">0</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># for t in range(target, 0, -1):</span></span><br><span class="line">        <span class="comment"># 为什么这里是正序</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">           <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> t - num &gt;= <span class="number">0</span>:</span><br><span class="line">                    f[t] += f[t - num]</span><br><span class="line">        <span class="keyword">return</span> f[target]</span><br></pre></td></tr></table></figure><p>正序遍历确保在计算 <code>f[t]</code> 时，<code>f[t - num]</code> 已经被计算过。这样可以正确地累加所有可能的组合数。</p><h1>2466 统计构造好字符串的方案数</h1><h2 id="回溯-5">回溯</h2><p>如果在回溯方案中，不每步进行 % (10 ** 9 + 7) ，则超出内存限制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countGoodStrings</span>(<span class="params">self, low: <span class="built_in">int</span>, high: <span class="built_in">int</span>, zero: <span class="built_in">int</span>, one: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 得到长为 i 的字符串</span></span><br><span class="line">        <span class="comment"># dfs(i) = dfs(i - zero) + dfs(i - one)</span></span><br><span class="line">        @ cache</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="comment"># mod = 10 ** 9 + 7</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i - one &lt; <span class="number">0</span> <span class="keyword">and</span> i - zero &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i - zero &gt; <span class="number">0</span> <span class="keyword">and</span> i - one &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> dfs(i - zero) % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">if</span> i - one &gt; <span class="number">0</span> <span class="keyword">and</span> i - zero &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> dfs(i - one) % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dfs(i - zero) + dfs(i - one) % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(dfs(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(low, high+<span class="number">1</span>)) % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure><h2 id="递推-7">递推</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 872ms</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countGoodStrings</span>(<span class="params">self, low: <span class="built_in">int</span>, high: <span class="built_in">int</span>, zero: <span class="built_in">int</span>, one: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 得到长为 i 的字符串</span></span><br><span class="line">        <span class="comment"># dfs(i) = dfs(i - zero) + dfs(i - one)</span></span><br><span class="line">        <span class="comment"># f[i] = f[i - zero] + f[i - one] # 需要正序</span></span><br><span class="line">        f = [<span class="number">0</span>] * (high + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>             <span class="comment"># f[i]表示长为i的方案数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, high + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt;= zero:</span><br><span class="line">                f[i] += f[i - zero]</span><br><span class="line">                <span class="comment"># f[i] += f[i - zero] % mod  </span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= one:</span><br><span class="line">                f[i] += f[i - one ]</span><br><span class="line">                <span class="comment"># f[i] += f[i - one ] % mod</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(f[low:]) % (<span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>若每步都除以mod,则执行用时优化到121ms</p><blockquote><p>时间复杂度：$O(N)$<br>空间复杂度：$O(N)$</p></blockquote><h1>740 删除并获得点数</h1><p>如何处理删除操作?</p><ol><li>打家劫舍中是<strong>相邻的房子不能连续偷</strong>。</li><li>这个题是<strong>相邻的数字不能同时拿</strong>（拿一个相邻的就删除了）</li></ol><h2 id="回溯-6">回溯</h2><p>选了nums[i]，然后 * 出现次数cnt，得到回报<br>dfs(i) i 表示选的数字，从nums中的最大值开始到0<br>选了 i ,则不能选 dfs(i-1) 和 dfs(i+1).</p><p>$$dfs(i) = max(dfs(i-2) + cnt[i] * i , dfs(i-1))<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAndEarn</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        cnt = [<span class="number">0</span>] * (<span class="number">10</span>**<span class="number">4</span> + <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            cnt[x] += <span class="number">1</span></span><br><span class="line">        maxx = <span class="built_in">max</span>(nums)</span><br><span class="line">        </span><br><span class="line">        @ cache</span><br><span class="line">        <span class="comment"># 删除nums[i] - 1 和 nums[i] + 1;不是 i-1 和 i+1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="comment"># 边界条件，处理完0 - maxx中的所有数</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(dfs(i-<span class="number">2</span>)+cnt[i]*nums[i], dfs(i-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># cnt[i] = 0 时得到的奖励也是0</span></span><br><span class="line">            <span class="comment"># if cnt[i] !=0:</span></span><br><span class="line">            <span class="comment">#     return max(dfs(i-2)+cnt[i]*i, dfs(i-1))</span></span><br><span class="line">            <span class="comment"># else:</span></span><br><span class="line">            <span class="comment">#     return dfs(i-1)</span></span><br><span class="line">        <span class="keyword">return</span> dfs(maxx)</span><br></pre></td></tr></table></figure><h2 id="递推-8">递推</h2><p>$$dfs(i) = max(dfs(i-2) + cnt[i] * i , dfs(i-1))<br>$$<br>$$f[i] = max(f[i-2] + cnt[i] * i ,f[i-1])<br>$$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteAndEarn</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        cnt = [<span class="number">0</span>] * (<span class="number">10</span>**<span class="number">4</span> + <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> nums:</span><br><span class="line">            cnt[x] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        maxx = <span class="built_in">max</span>(nums)</span><br><span class="line">        f = [<span class="number">0</span>] * (maxx + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxx + <span class="number">1</span>):</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i-<span class="number">2</span>] + cnt[i]*i, f[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> f[maxx]</span><br></pre></td></tr></table></figure><h1>213 打家劫舍 II</h1><p>房屋都 <strong>围成一圈</strong>：第一个房屋和最后一个房屋是紧挨着的<br>从最后一个房间开始dfs, 到最后一个的时候做个判断，如果此时选了最后一个房屋，flag = true ，不能选第一个房屋<br>不能选相邻的房间</p><h2 id="从后往前遍历">从后往前遍历</h2><ol><li>如果偷nums(n-1) , 那么 nums(0) 和 nums(n-2)不能选 ，问题变为nums(1)到 nums(n-3)的问题</li><li>如果不偷nums(n-1) ，问题变为nums(0)到 nums(n-2)的问题<br>$$dfs(i) = max(dfs(i-2)+nums[i],dfs(i-1)$$<br>$$f[i] = max(f[i-2]+nums[i],f[i-1])$$</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rob</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        g = [<span class="number">0</span>] * (n+<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 不选 nums(n-1)  # 需要最后加上nums[n-1]</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n-<span class="number">2</span>): <span class="comment"># 1-(n-3)</span></span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i-<span class="number">2</span>]+nums[i], f[i-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>): <span class="comment"># 0-(n-2)</span></span><br><span class="line">            g[i] = <span class="built_in">max</span>(g[i-<span class="number">2</span>]+nums[i], g[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f[n-<span class="number">3</span>]+nums[n-<span class="number">1</span>], g[n-<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h2 id="从前往后遍历">从前往后遍历</h2><ol><li>如果偷nums(0) , 那么 nums(1) 和 nums(n-1)不能选 ，问题变为nums(2)到 nums(n-2)的问题</li><li>如果不偷nums(0) ，问题变为nums(1)到 nums(n-1)的问题<br>下面空间优化的版本: 把时间复杂度优化成 $O(1)$<br>这个版本的代码需要画图理解下，有点写不出来<br><a href="https://leetcode.cn/problems/house-robber-ii/solutions/2445622/jian-ji-xie-fa-zhi-jie-diao-yong-198-ti-qhvri/">213. 打家劫舍 II - 力扣（LeetCode）</a></li></ol><h1>2915 和为目标值的最长子序列的长度</h1><p>回溯方案空间复杂度超限，只能用递推方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubsequence</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dfs(i, t) = max(dfs(i-1,t), dfs(i-1, t-x) + 1)</span></span><br><span class="line">        <span class="comment"># f[i][t] = max(f[i-1][t], f[i-1][t-x] + 1)</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f = [ [-inf] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(target + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> t &lt; x:</span><br><span class="line">                    f[i+<span class="number">1</span>][t] = f[i][t]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i+<span class="number">1</span>][t] = <span class="built_in">max</span>(f[i][t], f[i][t-x] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[n][target] <span class="keyword">if</span> f[n][target] != -inf <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 注意: 这里 (n-1) + 1 = n</span></span><br></pre></td></tr></table></figure><p>进一步优化空间复杂度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lengthOfLongestSubsequence</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dfs(i, t) = max(dfs(i-1,t), dfs(i-1, t-x) + 1)</span></span><br><span class="line">        <span class="comment"># f[i][t] = max(f[i-1][t], f[i-1][t-x] + 1)</span></span><br><span class="line">        <span class="comment"># 倒序 # f[t] = max(f[t], f[t-x] + 1)</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        f = [-inf] * (target + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(target, x-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                f[t] = <span class="built_in">max</span>(f[t], f[t-x] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[target] <span class="keyword">if</span> f[target] != -inf <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/posts/f92eff5d.html"/>
      <url>/posts/f92eff5d.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th></th></tr></thead><tbody><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17 电话号码的字母组合</a></td><td style="text-align:center">medium</td><td style="text-align:center">dfs</td><td style="text-align:center">7.22</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></td><td style="text-align:center">medium</td><td style="text-align:center">子集型dfs</td><td style="text-align:center">7.22</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/palindrome-partitioning/">131 分割回文串</a></td><td style="text-align:center">medium</td><td style="text-align:center">子集型dfs</td><td style="text-align:center">7.22</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">面试150</td><td style="text-align:center"><a href="https://leetcode.cn/problems/combinations/">77 组合</a></td><td style="text-align:center">medium</td><td style="text-align:center">组合型dfs</td><td style="text-align:center">7.23</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">字节题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/combination-sum-iii/">216 组合总和 III</a></td><td style="text-align:center">medium</td><td style="text-align:center">组合型dfs</td><td style="text-align:center">7.23</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100<br></td><td style="text-align:center"><a href="https://leetcode.cn/problems/generate-parentheses/">22 括号生成</a></td><td style="text-align:center">medium</td><td style="text-align:center">组合型dfs</td><td style="text-align:center">7.24</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/combination-sum/">39 组合总和</a></td><td style="text-align:center">medium</td><td style="text-align:center">组合型dfs or 完全背包</td><td style="text-align:center">7.24</td><td style="text-align:center"></td><td>完全背包代码没写</td></tr><tr><td style="text-align:center">灵神作业</td><td style="text-align:center"><a href="https://leetcode.cn/problems/remove-invalid-parentheses/">301. 删除无效的括号</a></td><td style="text-align:center">hard</td><td style="text-align:center">组合型回溯</td><td style="text-align:center"></td><td style="text-align:center"></td><td>一点儿不会(搁置一下)</td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/permutations/description/?envType=study-plan-v2&amp;envId=top-100-liked">46. 全排列 - 力扣（LeetCode）</a></td><td style="text-align:center">medium</td><td style="text-align:center">排列型dfs</td><td style="text-align:center">7.24</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/n-queens/">51 N 皇后</a></td><td style="text-align:center">hard</td><td style="text-align:center">排列型dfs</td><td style="text-align:center">7.24</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">灵神作业</td><td style="text-align:center"><a href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/">2850 将石头分散到网格图的最少移动次数</a></td><td style="text-align:center">medium</td><td style="text-align:center">排列型dfs</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></td><td style="text-align:center">medium</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><p>回溯有一个增量构造答案的过程。通过递归实现。只要写对边界条件和非边界条件的逻辑。</p><h1>回溯分类</h1><h2 id="子集型回溯">子集型回溯</h2><p>例题：78、131<br>每个元素都可以选/不选<br>0-1背包问题也可以算作一种子集型回溯<br>打家劫舍可以看作带一些约束的子集型回溯</p><h3 id="输入角度">输入角度</h3><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721649173044.webp" alt="1721649173044.png"></p><h3 id="答案角度">答案角度</h3><p>答案为 _ , _ , _ , __ , __ 长度为n</p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721650305866.webp" alt="1721650305866.png"><br>不考虑顺序，所以规定一个顺序：严格递增<br>i 表示枚举的起点<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721650655267.webp" alt="1721650655267.png"><br>由于子集的长度没有约束，所以每个节点都是答案 --&gt; 每次递归都需要记录一下答案</p><h2 id="组合型回溯">组合型回溯</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721718503411.webp" alt="1721718503411.png"></p><h3 id="剪枝技巧">剪枝技巧</h3><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721719295041.webp" alt="1721719295041.png"><br>剩下的可选的数i &lt; 小于待选的数d。<br>如果正序枚举，需要从[i,n]这 n-i+1个数中选， 不等式变为 n-i+1 &lt; d， 不等式会复杂一点。</p><h3 id="分析时间复杂度">分析时间复杂度</h3><p>公式：<strong>叶子的个数 * 从根到叶子的路径长度</strong></p><ol><li>站在输入角度：选 or 不选</li><li>站在答案角度：枚举选哪个</li></ol><h2 id="排列型回溯">排列型回溯</h2><h1>17 电话号码的字母组合</h1><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721646166802.webp" alt="1721646166802.png"><br>把数字和要枚举的字符对应起来<br>边界条件： digists的数字遍历完，返回 把path转换为字符串后的结果 (’ '.join(path))</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MAPPING = [<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;def&#x27;</span>, <span class="string">&#x27;ghi&#x27;</span>, <span class="string">&#x27;jkl&#x27;</span>,<span class="string">&#x27;mno&#x27;</span>, <span class="string">&#x27;pqrs&#x27;</span>, <span class="string">&#x27;tuv&#x27;</span>, <span class="string">&#x27;wxyz&#x27;</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">letterCombinations</span>(<span class="params">self, digits: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        path = [<span class="string">&#x27;&#x27;</span>] * n</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 目标字符串的第i个值搜索</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="comment"># 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(digits):</span><br><span class="line">                <span class="comment"># path收集够n，放进ans</span></span><br><span class="line">                ans.append(<span class="string">&#x27;&#x27;</span>.join(path))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 子问题:构造字符串 &gt;= i 的部分</span></span><br><span class="line">            <span class="comment"># 当前操作:对于digits的每个值</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> MAPPING[<span class="built_in">int</span>(digits[i])]:</span><br><span class="line">                path[i] = c</span><br><span class="line">                dfs(i+<span class="number">1</span>)</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：$O(N*4^N)$<br>每个数字对应的字符最多为4, 枚举每个字符对应一个循环，最多需要循环$4^N$次<br>生成答案处，需要花$O(N)$的时间<br>空间复杂度：$O(N)$</p></blockquote><h1>78 子集</h1><p>子集型回溯</p><h2 id="枚举输入">枚举输入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="comment"># 对于第i个数，选 or 不选</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="comment"># ans.append(path)</span></span><br><span class="line">                <span class="comment"># path是全局变量，这里需要固定答案</span></span><br><span class="line">                <span class="comment"># copy 是值拷贝，不是引用拷贝</span></span><br><span class="line">                <span class="comment"># 要是不copy的话，path变了，对应的ans也会变</span></span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 不选</span></span><br><span class="line">            dfs(i + <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 选</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            dfs(i + <span class="number">1</span>)</span><br><span class="line">            path.pop()            <span class="comment"># 恢复现场</span></span><br><span class="line">            </span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：$O(N*2^N)$<br>每次递归有不选和选两种情况，所以为$O(2^N)$;copy的时间是$O(N)$的<br>空间复杂度：$O(N)$</p></blockquote><h2 id="枚举答案">枚举答案</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># i 表示枚举的起点</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            ans.append(path.copy())</span><br><span class="line">            <span class="comment"># 边界条件</span></span><br><span class="line">            <span class="keyword">if</span> i == n :</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 枚举当前要填的数字</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                path.append(nums[j])</span><br><span class="line">                dfs(j+<span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">                </span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1>131 分割回文串</h1><p>枚举字符串之间的逗号分隔，对于每个逗号 选/不选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">case1(长度为1) --&gt; 是</span><br><span class="line">case2(长度大于1) --&gt; 后一半翻转后与前一半比较</span><br><span class="line">回文字符串判定 --&gt; case1 &amp; case2</span><br></pre></td></tr></table></figure><h2 id="输入角度-2">输入角度</h2><p>对于每一个间隔位置，选或者不选逗号。<br>注意，'aab’字符串的末尾处一定加逗号， 为了取出最后剩下的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 输入角度，遍历i和i+1之间的位置</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, start</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 不选 如果是 i= n-1 必须选加入逗号，表示在s的最后面截断</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; n-<span class="number">1</span>:</span><br><span class="line">                dfs(i + <span class="number">1</span>, start)</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 选</span></span><br><span class="line">            <span class="comment"># 切片的性质，含起始索引，不含结尾索引</span></span><br><span class="line">            t = s[start : i+<span class="number">1</span>]   <span class="comment"># s[start] -- s[i] 含s[i]</span></span><br><span class="line">            <span class="keyword">if</span> t == t[::-<span class="number">1</span>]:     <span class="comment"># 回文字符串，记录路径</span></span><br><span class="line">                path.append(t)</span><br><span class="line">                dfs(i + <span class="number">1</span>, i + <span class="number">1</span>) <span class="comment"># 从下标i+1开始</span></span><br><span class="line">                path.pop()  <span class="comment"># 恢复现场</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="答案角度-2">答案角度</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721658097523.webp" alt="1721658097523.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="comment"># 答案角度，枚举,的位置</span></span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="comment"># 子串的开始位置</span></span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n): <span class="comment"># 枚举子串的结束位置，即在j后面加，</span></span><br><span class="line">                t = s[i : j+<span class="number">1</span>]    <span class="comment"># 包含s[j]</span></span><br><span class="line">                <span class="keyword">if</span> t == t[::-<span class="number">1</span>]:  <span class="comment"># 判断是否回文</span></span><br><span class="line">                    path.append(t)</span><br><span class="line">                    dfs(j+<span class="number">1</span>)      <span class="comment"># 下一个子串开始位置</span></span><br><span class="line">                    path.pop()</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度分析：$O(N*2^N)$</p><ol><li>t == t[::-1]检查一个子串是否为回文。这个操作的时间复杂度为 O(k)，k为字串长度，最坏为O(n)</li><li>最坏情况下，DFS 会遍历所有可能的划分。每个字符有两种选择：要么作为当前子串的一部分，要么作为下一个子串的开头。这样，总共有$2^{n-1}$种可能的划分方式。</li><li>回文检查的时间复杂度$O(n)$ + 递归调用次数$2^{n-1}$ + 每次递归操作的时间复杂度$O(n)$<br>空间复杂度：$O(N)$</li></ol></blockquote><h1>77 组合</h1><h2 id="输入角度-3">输入角度</h2><p>选 or 不选： 如果可选数i &gt; 要选数d， 那么可以不选</p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721721922563.webp" alt="1721721922563.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="comment"># 可选[0,i]</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            d = k - <span class="built_in">len</span>(path)</span><br><span class="line">            <span class="comment"># 边界</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == k :</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 不选</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; d:</span><br><span class="line">                dfs(i - <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 选</span></span><br><span class="line">            path.append(i)</span><br><span class="line">            dfs(i - <span class="number">1</span>)</span><br><span class="line">            path.pop() <span class="comment"># 恢复现场</span></span><br><span class="line">        dfs(n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>不剪枝的话，增加 i == 0 ，return 的边界判断</p><h2 id="答案角度-3">答案角度</h2><p>剪枝后的树：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721720606242.webp" alt="1721720606242.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="comment"># 起始为i : 对于[n, 0]</span></span><br><span class="line">        <span class="comment"># `i` 表示在当前递归层级中可以选择的最大数字</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            d = k - <span class="built_in">len</span>(path) <span class="comment"># 剩余要选的数字</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 边界条件: 选够k个数</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 倒序遍历</span></span><br><span class="line">            <span class="comment"># for j in range(i, 0, -1):</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, d-<span class="number">1</span>, -<span class="number">1</span>): <span class="comment"># 剪枝</span></span><br><span class="line">                path.append(j)</span><br><span class="line">                dfs(j - <span class="number">1</span>)</span><br><span class="line">                path.pop() <span class="comment"># 恢复现场</span></span><br><span class="line">        dfs(n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>从n个数中选k个数的组合</p><blockquote><p>时间复杂度公式：叶子的个数 * 从根到叶子的路径长度<br>叶子的个数为 $C_n^k$，从根到叶子的路径path的长度为$k$<br>时间复杂度: $kC_n^k$<br>空间复杂度:$O(k)$</p></blockquote><h1>216 组合总和 III</h1><p>找出所有相加之和为 n 的 k 个数的组合<br>1-9，且每个数字最多使用一次</p><h2 id="输入角度-4">输入角度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        self.sumn = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 选 or 不选</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            d = i * (i+<span class="number">1</span>) / <span class="number">2</span>    <span class="comment"># 还能表示的和</span></span><br><span class="line">            <span class="keyword">if</span> self.sumn == n <span class="keyword">and</span> <span class="built_in">len</span>(path) == k:  </span><br><span class="line">                ans.append(path.copy()) <span class="comment"># 记录答案</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:  <span class="comment"># 边界</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 不选</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; k - <span class="built_in">len</span>(path) <span class="keyword">and</span> d &gt; n - self.sumn :</span><br><span class="line">                dfs(i-<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 选</span></span><br><span class="line">            path.append(i)</span><br><span class="line">            self.sumn += i</span><br><span class="line">            dfs(i-<span class="number">1</span>)</span><br><span class="line">            path.pop()       <span class="comment"># 恢复现场</span></span><br><span class="line">            self.sumn -= i</span><br><span class="line">        dfs(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="答案角度-4">答案角度</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721724447084.webp" alt="1721724447084.png"><br>自己写的版本：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721743554472.webp" alt="1721743554472.png"><br>优化：</p><ol><li>若路径长度为 k ,d = 0 ，那 (i * 2 - d + 1) * d / 2也是等于0的<ol><li>若t &lt; 0 , 则直接不成立</li><li>若t &gt; 0 , t &gt; 0成立，也直接return</li><li>因此只有t = 0 这个情况，所以不必判断</li></ol></li><li>把target 作为dfs传入的变量处理</li></ol><p>优化后的代码(参考灵神)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, t</span>):</span><br><span class="line">            d = k - <span class="built_in">len</span>(path)</span><br><span class="line">            <span class="comment"># 剪枝</span></span><br><span class="line">            <span class="keyword">if</span> t &lt; <span class="number">0</span> <span class="keyword">or</span> t &gt; (i * <span class="number">2</span> - d + <span class="number">1</span>) * d //<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == k:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># d-1为数目的剪枝</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, d-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                path.append(j)</span><br><span class="line">                dfs(j-<span class="number">1</span>, t-j)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">9</span>, n)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度: $O(k * C_9^k)$<br>空间复杂度: $O(k)$  递归 k 层 ，栈的长度为 k</p></blockquote><h1>22 括号生成</h1><p>长为 2n 的有效括号组合<br>左右括号的个数都必须等于n</p><h2 id="输入角度-5">输入角度</h2><p>可以看成是从 2n 中选 n 个位置放左括号，其余位置放右括号<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721803786990.webp" alt="1721803786990.png"><br>n = 3 ，左括号的个数不能超过3 ，所以一旦已经选了 3 个做括号，后面只能不选。<br>右括号的个数不能超过左括号，如果左右括号相等的时候，只能选左括号。</p><ol><li>剪枝：if 左括号的个数 &gt;= n : 不选</li></ol><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721803975040.webp" alt="1721803975040.png"></p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721805257095.webp" alt="1721805257095.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># 选 or 不选</span></span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="comment"># 共 2n 个位置</span></span><br><span class="line">        <span class="comment"># 当前位置为 i</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, openl:<span class="built_in">int</span></span>): <span class="comment"># open 表示左括号的个数</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span>* n :</span><br><span class="line">                <span class="comment"># ans.append(path.copy)  # 这样不行</span></span><br><span class="line">                ans.append(<span class="string">&#x27;&#x27;</span>.join(path.copy()))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 如果左括号的个数 &lt; n,可以选左括号</span></span><br><span class="line">            <span class="keyword">if</span> openl &lt; n:</span><br><span class="line">                path.append(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                dfs(i + <span class="number">1</span>, openl + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 如果右括号个数 &lt; 左括号，可以选右括号</span></span><br><span class="line">            <span class="keyword">if</span> i - openl &lt; openl:</span><br><span class="line">                path.append(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">                dfs(i + <span class="number">1</span>, openl)</span><br><span class="line">                path.pop()</span><br><span class="line">                </span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度: $O(n*C_{2n}^n)$<br>空间复杂度: $O(n)$</p></blockquote><p>由于左右括号之间是有约束的，所以实际的递归次数并没有那么多。详见卡特兰数(Catalan)</p><h2 id="答案角度-5">答案角度</h2><p>枚举下一个左括号的位置<br><strong>这个方法不懂，晚点重新看下题解</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="comment"># balance = 左括号个数 - 右括号个数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i: <span class="built_in">int</span>, balance: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == n:</span><br><span class="line">                s = [<span class="string">&#x27;)&#x27;</span>] * (n * <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> path:</span><br><span class="line">                    s[j] = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">                ans.append(<span class="string">&#x27;&#x27;</span>.join(s))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 可以填 0 到 balance 个右括号</span></span><br><span class="line">            <span class="keyword">for</span> close <span class="keyword">in</span> <span class="built_in">range</span>(balance + <span class="number">1</span>):  <span class="comment"># 填 close 个右括号</span></span><br><span class="line">                path.append(i + close)  <span class="comment"># 填 1 个左括号</span></span><br><span class="line">                dfs(i + close + <span class="number">1</span>, balance - close + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1>39 组合总和</h1><h2 id="输入角度-6">输入角度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, t</span>):</span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> t &lt; <span class="number">0</span> <span class="keyword">or</span> i == <span class="built_in">len</span>(candidates):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 不选candidates[i]</span></span><br><span class="line">            dfs(i+<span class="number">1</span>, t)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 选candidates[i]</span></span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            dfs(i, t - candidates[i]) <span class="comment"># 可以重复选</span></span><br><span class="line">            path.pop()</span><br><span class="line">            </span><br><span class="line">        dfs(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p><strong>剪枝优化</strong><br>把 candidates 从小到大排序，如果递归中发现 t&lt;candidates[i]，由于后面的数字只会更大，所以无法把 t 减小到 0，可以直接返回。<br><a href="https://leetcode.cn/problems/combination-sum/solutions/2747858/liang-chong-fang-fa-xuan-huo-bu-xuan-mei-mhf9/?envType=study-plan-v2&amp;envId=top-100-liked">时间复杂度分析</a><br><strong>用完全背包分析的，还不太会</strong></p><h2 id="答案角度-6">答案角度</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment">#  无限制重复被选取</span></span><br><span class="line">        <span class="comment"># 答案角度</span></span><br><span class="line">        ans = []</span><br><span class="line">        path = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, t</span>):</span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> t &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 第 i 个位置可选的候选 candidates[j]</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                path.append(candidates[j])</span><br><span class="line">                <span class="comment"># 这里递归调用dfs，不需要加1，因为可以重复选取</span></span><br><span class="line">                dfs(j, t - candidates[j])</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>, target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1>301 删除无效的括号</h1><h1>46 全排列</h1><p>不含重复数字，全排列的个数是数组长度的阶乘。<br>相比组合，在排列中，元素的顺序是有去别的。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721821898301.webp" alt="1721821898301.png"></p><p>选了一个数之后，如何告诉下面还可以选哪些数呢？</p><h2 id="set写法">set写法</h2><p>数组 path 记录路径上的数（已选数字），集合s记录剩余未选数字<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721821841138.webp" alt="1721821841138.png"></p><p>当前操作是指：只枚举下标 i 要填什么，和更大的下标无关<br>下一个子问题，要从集合$s$去掉选的那个数字$x$<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721822464475.webp" alt="1721822464475.png"><br>注意：</p><ol><li>set() 用 全部可选数据 nums 进行初始化</li><li>从集合set()中去掉某一个数，用s - {x}</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = []</span><br><span class="line">        path = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="comment"># 当前填的是path[i],s表示可以填的集合</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, s</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">                path[i] = x</span><br><span class="line">                dfs(i + <span class="number">1</span>, s - &#123;x&#125;)</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="built_in">set</span>(nums))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度：</p><ol><li>如果用叶子个数 * 从根到叶子节点的路径长度计算，那时间复杂度为$O(n\cdot n!)$，复制路径也换占用$O(n)$的时间</li><li>节点个数为$O(n!)$，copy()时间的为$O(n)$，时间复杂度为$O(n\cdot n!)$<br>空间复杂度：除去答案ans，其余用到的空间是$O(n)$</li></ol></blockquote><h2 id="更精确的时间复杂度分析">更精确的时间复杂度分析</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721823324887.webp" alt="1721823324887.png"><br>在O记号下，只要是分叉大于等于2的树，它的节点个数是等于叶子个数的，时间复杂度为$O(n!)$<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721823650991.webp" alt="1721823650991.png"></p><h2 id="bool-数组写法">bool 数组写法</h2><p>更通用的做法：把哈希表set()改为bool数组，只选不再路径中的数<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721823754225.webp" alt="1721823754225.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        ans = []</span><br><span class="line">        path = [<span class="number">0</span>] * n</span><br><span class="line">        onpath = [<span class="literal">False</span>] * n</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前填的是path[i]</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> onpath[j] <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                    path[i] = nums[j]</span><br><span class="line">                    onpath[j] = <span class="literal">True</span></span><br><span class="line">                    dfs(i + <span class="number">1</span>)</span><br><span class="line">                    onpath[j] = <span class="literal">False</span> <span class="comment"># 恢复现场</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1>51 N皇后</h1><h2 id="set写法-2">set写法</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721825692255.webp" alt="1721825692255.png"><br>判断同斜线本质是一次函数求截距<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721825707634.webp" alt="1721825707634.png"></p><ol><li>对于每一行 r ,枚举可以放的列号 set()</li><li><strong>生成棋盘</strong>：如果在第c列放皇后(0-c)，前面有c个空格，后面有n-1-c个空格</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        col = [<span class="number">0</span>] * n     <span class="comment"># 表示第i行对应的列号</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">i, x</span>):</span><br><span class="line">            <span class="comment"># 左上和右上</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i): <span class="comment"># 小于 i 的行</span></span><br><span class="line">                r = j</span><br><span class="line">                c = col[j]</span><br><span class="line">                <span class="keyword">if</span> r + c == i + x <span class="keyword">or</span> r - c == i - x:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第 i 行 , 可选的列数集合s</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i, s</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                ans.append([<span class="string">&#x27;.&#x27;</span> * c + <span class="string">&#x27;Q&#x27;</span> + <span class="string">&#x27;.&#x27;</span>*(n-<span class="number">1</span>-c) <span class="keyword">for</span> c <span class="keyword">in</span> col])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">                <span class="comment"># 在第i行x列放皇后合法</span></span><br><span class="line">                <span class="keyword">if</span> check(i, x):</span><br><span class="line">                    col[i] = x</span><br><span class="line">                    dfs(i+<span class="number">1</span>, s-&#123;x&#125;)</span><br><span class="line">                    </span><br><span class="line">        dfs(<span class="number">0</span>, <span class="built_in">set</span>(<span class="built_in">range</span>(<span class="number">0</span>,n)))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>时间复杂度:$O(n^2\cdot n!)$<br>因为可以转换为全排列问题，只是多了判断斜线<br>生成答案的时间复杂度为$O(n^2)$<br>空间复杂度:$O(n)$</p></blockquote><h2 id="优化">优化</h2><p>由于用了循环判断当前位置能不能放皇后，消耗了O(n)的时间，如何优化为$O(1)$呢？<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1721827884737.webp" alt="1721827884737.png"><br>如果皇后放在右上角，会得到 -(n-1)<br>m的大小可以理解为(0, 0)到(n-1, n-1)的所有坐标之和为(2n-2, 2n-2)，对应的数组长度为2n-1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        col = [<span class="number">0</span>] * n     <span class="comment"># 表示第i行对应的列号</span></span><br><span class="line">        on_path = [<span class="literal">False</span>] * n <span class="comment"># 第 j 列是否选过</span></span><br><span class="line">        m = <span class="number">2</span>*n - <span class="number">1</span></span><br><span class="line">        diag1 = [<span class="literal">False</span>] * m   <span class="comment"># r+c</span></span><br><span class="line">        diag2 = [<span class="literal">False</span>] * m   <span class="comment"># r-c</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):           <span class="comment"># 第i行</span></span><br><span class="line">            <span class="keyword">if</span> i == n :</span><br><span class="line">                ans.append([<span class="string">&#x27;.&#x27;</span>*c + <span class="string">&#x27;Q&#x27;</span> + <span class="string">&#x27;.&#x27;</span>*(n-<span class="number">1</span>-c) <span class="keyword">for</span> c <span class="keyword">in</span> col])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n):  <span class="comment"># 第x列</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> on_path[x] <span class="keyword">and</span> <span class="keyword">not</span> diag1[i + x] <span class="keyword">and</span> <span class="keyword">not</span> diag2[i-x + n-<span class="number">1</span>]:</span><br><span class="line">                    col[i] = x  <span class="comment"># 放皇后</span></span><br><span class="line">                    on_path[x], diag1[i+x], diag2[i-x + n-<span class="number">1</span>] = <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">True</span></span><br><span class="line">                    dfs(i + <span class="number">1</span>)</span><br><span class="line">                    on_path[x], diag1[i+x], diag2[i-x + n-<span class="number">1</span>] = <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>时间复杂度是一样的<br>51 题 和52题一样，52返回len(ans)即可</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归的底层理解</title>
      <link href="/posts/d924dd47.html"/>
      <url>/posts/d924dd47.html</url>
      
        <content type="html"><![CDATA[<h1>递归结构</h1><p>递归的基本思想就是 “自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己<br>👉递归结构包括两个部分：</p><ul><li>定义递归头<br>（1）作用：递归的结束条件<br>（2）如果没有头，将陷入死循环</li><li>定义递归体<br>（1）作用：满足条件调用自身的方法<br>👉递归作用：利用递归，可以使用简单的程序来解决一些复杂的问题。比如斐波那契数列的计算、汉诺塔、快速排列等问题。</li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f59e939d71d4638a84fcb4753acad20~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt=""></p><h1>递归调用过程</h1><ol><li>程序执行一个函数时，就创建一个新函数栈</li><li>函数的局部变量是独立的，不会相互影响</li><li>递归必须符合退出递归的条件才行，否则就是无限递归，死循环</li><li>当一个函数执行完毕，或者遇到 return，就会返回，遵守谁调用，就将结果返回给谁。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Runge-Kutta Integrator</title>
      <link href="/posts/88a27363.html"/>
      <url>/posts/88a27363.html</url>
      
        <content type="html"><![CDATA[<h1>Runge-Kutta 2</h1><p>前向欧拉法：<br>$$x_{k+1} = x_{k} + \Delta tf(x_{k},t_{k})$$<br>Runge-Kutta 2 :<br>$$x_{k+1} = x_{k} + \Delta tf(x_{k} + \frac{\Delta t}{2}f(x_k,t_k),t_{k}+ \frac{\Delta t}{2})$$<br>或者写为:<br>$$x_{k+1} = x_{k} + \Delta t f_2$$<br>$$f_1 = f(x_{k},t_{k})$$<br>$$f_2 = f(x_k+ \frac{\Delta t}{2}f_1),t_{k}+ \frac{\Delta t}{2}))$$<br>在当前$x_k$上，在$f_2$方向采取$\Delta t$步<br>$f_1$先找到时间$t_k$处的$x_k$向量是什么，即基点处的向量场。<br>$f_2$在$f_1$方向上走半步，然后查询现在的向量场获取$f_2$。有了$f_2$后，采用完整的欧拉步骤。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720876303074.webp" alt="1720876303074.png"><br>前向欧拉仅获得切线方向，它将离开实际的曲线。RK2进行半点查询，然后采用该方向进行校正</p><h1>Runge-Kutta 4</h1><p>$$x_{k+1} = x_{k} + \frac{\Delta t}{6} (f_1 + 2f_2 + 2f_3 + f_4)$$<br>取四个方向的平均值，$f_1$和$f_2$没有改变。<br>$$f_1 = f(x_{k},t_{k})$$<br>$$f_2 = f(x_k+ \frac{\Delta t}{2}f_1),t_{k}+ \frac{\Delta t}{2}))$$<br>$f_3$在$f_2$的基础上走半步。<br>$$f_3 = f(x_k+ \frac{\Delta t}{2}f_2),t_{k}+ \frac{\Delta t}{2}))$$<br>$f_4$在$f_3$的基础上走一整步。<br>$$f_4 = f(x_k+ \Delta tf_3),t_{k}+ \Delta t))$$<br>理论来自泰勒级数。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720877599119.webp" alt="1720877599119.png"></p><h1>Runge-Kutta 45</h1><p>采用自适应步骤，如果他们认为错误很小，他们会将时间步长加倍。可以根据轨迹的曲率对问题采取正确的时间步长。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Blog主题修改</title>
      <link href="/posts/2979ebd4.html"/>
      <url>/posts/2979ebd4.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Tool_Learn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Physics-informed neural network</title>
      <link href="/posts/ae228ea9.html"/>
      <url>/posts/ae228ea9.html</url>
      
        <content type="html"><![CDATA[<p>物理信息神经网络：用于解决涉及非线性偏微分方程的正向和逆向问题的深度学习框架<br>应用：代替传统数值解法<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720526629327.webp" alt="1720526629327.png"></p><h1>Forward</h1><blockquote><p>data-driven solution PDE的新型数值求解器</p></blockquote><h2 id="Burger’s-Equation">Burger’s Equation</h2><h3 id="PDE">PDE</h3><p>$$\frac{\partial u}{\partial t}+ u\frac{\partial u}{\partial x}=\nu\frac{\partial^2 u}{\partial x^2} $$<br>$$x\in[-1,1]$$<br>$$t\in[0,1]$$<br>所以，$u(t,x)$满足:<br>$$u_t+u(u_x)-\nu u_{xx}=0$$<br>使用DNN $NN(t,x)$$来逼近$u(t,x), 即:<br>$$NN(t,x)\approx u(t,x)$$<br>因为 $NN(t,x)$是一个函数，可以用Torch中的AD得到它的导数:$\frac{\partial NN}{\partial t},\frac{\partial^2 NN}{\partial x^2}$<br>定义:<br>$$f(t,x)=\frac{\partial NN}{\partial t}+N(\frac{\partial NN}{\partial x})-\nu\frac{\partial^2 NN}{\partial x^2}$$<br>若$f\rightarrow 0$，那么NN遵循物理规律。</p><h3 id="Loss-function">Loss function</h3><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720529929416.webp" alt="1720529929416.png"><br>包含2个部分，第一部分是满足物理的PDE的MSE，第二部分是<strong>边界条件和初始条件的MSE</strong></p><ol><li>在时空域(x,t)内用LHS超立方采样取$N_f$个点评估是否满足PDE方程：<br>$$MSE_f=\frac{1}{N_f}\sum^{N_f}_{i=1}|f(t_f^i,x_f^i)|^2$$</li><li>训练集数据一般取我们可以知道的点，比如边界(BC)和初始条件下(IC)的值。从BC和IC中随机采样$N_u$个点作为训练集，采用&quot;无监督&quot;训练PINN。<br>$$MSE_{u}=\frac{1}{N_u}\sum^{N_u}<em>{i=1}|y(t</em>{u}^i,x_u^i)-NN(t_{u}^i,x_u^i)|^2$$</li><li>Total Loss:$$MSE=MSE_{u}+MSE_f$$<br>详细形式：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720697635378.webp" alt="1720697635378.png"><br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720684697726.webp" alt="1720684697726.png"></li></ol><h1>Inverse</h1><blockquote><p>data-driven discovery of partial differential equations<br>用于模型反演和系统识别的新的数据驱动方法</p></blockquote><p>给定一些时空数据，学习 PDE 的参数 + PINN 的参数</p><h2 id="Navier–Stokes-equation">Navier–Stokes equation</h2><blockquote><p>描述了不可压缩流体流动的现实场景。它们可用于模拟天气、洋流、管道中的水流和机翼周围的气流。</p></blockquote><h3 id="PDE-2">PDE</h3><p>$$u_t+\lambda_1(uu_x+vu_y)=-p_x+\lambda_2(u_{xx}+u_{yy})$$<br>$$v_t+\lambda_1(uv_x+vv_y)=-p_y+\lambda_2(v_{xx}+v_{yy}),$$<br>流体的质量守恒:$$u_x + v_y = 0$$<br>$$u=\psi_y,\quad v=-\psi_x,$$<br>速度场的 $x$ 分量 $u(t,x,y)$ ，$y$ 分量 $v(t,x,y)$ ，压力:  $p(t,x,y)$<br>已知含有噪声的数据:  ${t^i,x^i,y^i,u^i,v^i}_{i=1}^N$<br>求解:PDE中的未知参数$\lambda_1$和$\lambda_2$，以及PINN的参数<br>定义基于物理的两个函数$f(t,x,y)$和$g(t,x,y)$，其中 $u$ 和 $v$ 用DNN近似:</p><p>$$f:=u_t+\lambda_1(uu_x+vu_y)+p_x-\lambda_2(u_{xx}+u_{yy})$$</p><p>$$g:=v_t+\lambda_1(uv_x+vv_y)+p_y-\lambda_2(v_{xx}+v_{yy})$$</p><p>输入:$t,x,y$<br>输出:$\Phi(t,x,y)$和$P(t,x,y)$</p><h3 id="Loss-function-2">Loss function</h3><p>包含2个部分，第一部分是满足物理的PDE的MSE，第二部分是<strong>数据点的残差</strong>。<br>训练集采用spectral/hp-element solver NekTar 求解产生。<br>$$<br>MSE:=\frac1N\sum_{i=1}^N\left(|u(t^i,x^i,y^i)-u^i|^2+|v(t^i,x^i,y^i)-v^i|^2\right)+\frac1N\sum_{i=1}^N\left(|f(t^i,x^i,y^i)|^2+|g(t^i,x^i,y^i)|^2\right).<br>$$<br>训练集：从含有噪声的数据: ${t^i,x^i,y^i,u^i,v^i}_{i=1}^N$ 中随机抽取N = 5,000的数据(仅相当于可用数据总数的 1%)，验证PINN具有从分散和稀缺的训练数据中学习的能力。</p><h3 id="结果">结果</h3><ol><li>即使训练数据被噪声破坏，PINN也能够以非常高的精度正确识别未知参数 $\lambda_1$ 和 $\lambda_2$ 。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720689987864.webp" alt="1720689987864.png"></li><li>PINN能够在没有任何关于压力本身的训练数据的情况下对整个压力场 $p(t, x, y)$ 提供定性准确的预测。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720690178459.webp" alt="1720690178459.png"></li></ol><h1>分析</h1><h2 id="好处">好处</h2><ol><li><strong>无网格</strong> 与求解PDE的任何经典数值方法都不同，不需要做时空离散化。</li><li>对于高阶PDE也有很好的效果</li><li>能够扩展到求解逆问题和PDE方程发现问题上</li><li>只需要稀疏的训练值，就可以得到误差很小的$u(x,t)$</li><li>无监督</li></ol><h2 id="限制">限制</h2><ol><li>计算成本很大(前向训练之用AD计算其导数，但是优化环节是缓慢的。全连接网络所以慢 )</li><li>收敛性(计算loss时需要设置各部分权重超参数$\lambda$。$\lambda$太小，不能学到通用的解。$\lambda$太大，只学到边界条件，忽略了物理loss。loss会剧烈颠簸，不稳定，训练轮数需要比较大15K+)</li></ol><h1>离散RK-PINN</h1><p>$$\frac{\partial u}{\partial t}= - \mathcal N[u]$$<br>应用显式的Runge-Kutta方法：</p><ol><li>对于每个时间步$n$,中间步$c_i$:<br>$$u^{n+c_i}=u^n - \Delta t\sum_{j=1}^qa_{ij}\mathcal{N}[u^{n+c_j}],\quad i=1,\ldots,q,$$</li><li>更新$u$到$n+1$:(总结所有中间步骤，得到最终的结果更新公式)<br>$$u^{n+1}=u^n - \Delta t\sum_{j=1}^qb_j\mathcal{N}[u^{n+c_j}].$$<br>$a_ij$是RK方法的系数矩阵，$b_j$是权重系数。<br>以RK4为例：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720879073722.webp" alt="1720879073722.png"></li></ol><p>通过将多输出神经网络的预测结果代入显式Runge-Kutta方法的更新公式，我们得到物理信息输出：<br>$$\begin{bmatrix}u_1^n(x),\ldots,u_q^n(x),u_{q+1}^n(x)\end{bmatrix}$$<br>我们可以利用神经网络预测的未来状态结合物理方程，生成相应的物理信息输出，从而实现对复杂动力系统的有效建模和预测。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720882502236.webp" alt="1720882502236.png"><br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720882521737.webp" alt="1720882521737.png"></p><h2 id="优势">优势</h2><p>在经典数值分析中，由于显式方案的稳定性约束或隐式公式的计算复杂性约束，这些时间步长通常被限制为很小。随着龙格-库塔阶数$q$的增加，这些约束变得更加严格，并且对于大多数实际感兴趣的问题，需要采取数千到数百万个这样的步骤，直到解决方案达到所需的最终时间。</p><ol><li>在PINN，我们可以采用具有任意大量阶数$q$的隐式龙格-库塔方案，而实际上几乎没有额外成本。使我们能够采取非常大的时间步长，同时保持稳定性和高预测准确性，使我们能够一步解决整个时空预测。</li><li><strong>训练数据很小</strong>(训练数据集由$N_n = 200$个初始数据点组成，这些数据点是在时间 $t = 0.1$ 时从精确解中随机二次采样的)。使用 $\Delta t = 0.8$ 的单个时间步来预测时间 $t = 0.9$ 时的解。</li><li><strong>误差很小</strong></li><li>通过使用高阶隐式Runge-Kutta方案和物理信息神经网络，我们可以在单一时间步长内准确预测从平滑初始数据到近乎不连续解的演变</li></ol><h1>参考资料</h1><ol><li>PINN的一些思考和拓展</li></ol><div style="border: 1px solid #ccc; padding: 16px; width: 100%; margin: auto;">  <a href="https://www.youtube.com/watch?v=qYmkUXH7TCY" target="_blank" style="text-decoration: none; color: inherit;">    <img src="https://img.youtube.com/vi/qYmkUXH7TCY/maxresdefault.jpg" alt="Rethinking Physics Informed Neural Networks [NeurIPS′21]" style="width: auto; height: 300px; display: block; margin: auto;">    <h2 style="font-size: 1.5em; margin: 0.5em 0;">Rethinking Physics Informed Neural Networks [NeurIPS′21]</h2>  </a>  <p style="font-size: 1em; color: #555;">Link to the slides: <a href="http://amirgholami.org/assets/talks/2021_10_22_Rethinking_PINNs.pdf" target="_blank">http://amirgholami.org/assets/talks/2021_10_22_Rethinking_PINNs.pdf</a><br>  Link to the paper: <a href="https://openreview.net/pdf?id=a2Gr9gNFD-J" target="_blank">https://openreview.net/pdf?id=a2Gr9gNFD-J</a></p></div><ol start="2"><li>PINN简要讲解</li></ol><div style="border: 1px solid #ccc; padding: 16px; width: 100%; max-width: 800px; margin: auto;">  <a href="https://www.youtube.com/watch?v=kDlrOanVtf8" target="_blank" style="text-decoration: none; color: inherit; display: block;">    <img src="https://img.youtube.com/vi/kDlrOanVtf8/sddefault.jpg" alt="Physics Informed Neural Networks" style="width: auto; height: 300px; object-fit: cover;">    <h2 style="font-size: 1.5em; margin: 0.5em 0;">Physics Informed Neural Networks</h2>  </a></div><ol start="3"><li>ODE 求解思想和纯手写Code</li></ol><div style="border: 1px solid #ccc; padding: 16px; width: 100%;height:auto;  margin: auto;">  <a href="https://benmoseley.blog/my-research/so-what-is-a-physics-informed-neural-network/" target="_blank" style="text-decoration: none; color: inherit; display: block;">    <img src="https://benmoseley.blog/wp-content/uploads/2021/08/pinn-feature-1024x577.png" alt="So, what is a physics-informed neural network? - Ben Moseley" style="width: auto; height: 230px; object-fit: cover;">    <h2 style="font-size: 1.5em; margin: 0.5em 0;">So, what is a physics-informed neural network? </h2>  </a></div><p>下面视频的 14:10给了，若有Enternal Force时如何建模</p><div style="border: 1px solid #ccc; padding: 16px; width: 100%; max-width: 800px; margin: auto;">  <a href="https://www.youtube.com/watch?v=G_hIppUWcsc&t=130s" target="_blank" style="text-decoration: none; color: inherit; display: block;">    <img src="https://img.youtube.com/vi/G_hIppUWcsc/sddefault.jpg" alt="Physics Informed Neural Networks" style="width: auto; height: 300px; object-fit: cover;">    <h2 style="font-size: 1.5em; margin: 0.5em 0;">Physics-Informed Neural Networks (PINNs) - An Introduction - Ben Moseley | Jousef Murad</h2>  </a></div>4. PDE Code原文中给的Burgers Equation的PyTorch版本源码：<div style="border: 1px solid #ccc; padding: 16px; width: 100%;height:auto;  margin: auto;">  <a href="https://github.com/jdtoscano94/Learning-Scientific_Machine_Learning_Residual_Based_Attention_PINNs_DeepONets/tree/main/Tutorials/PINNs" target="_blank" style="text-decoration: none; color: inherit; display: block;">    <img src="https://opengraph.githubassets.com/7235f2346d97590b0ec1e4997a1062302a61b05351d037e3f594b65b5896bfc8/jdtoscano94/Learning-Scientific_Machine_Learning_Residual_Based_Attention_PINNs_DeepONets" alt="So, what is a physics-informed neural network? - Ben Moseley" style="width: auto; height: 200px; object-fit: cover;">    <h2 style="font-size: 1.5em; margin: 0.5em 0;">Learning-Scientific_Machine_Learning_Residual_Based_Attention_PINNs_DeepONets/Tutorials/PINNs at main · jdtoscano94/Learning</h2>  </a></div><ol start="5"><li>DeepXDE 做了一些巧妙地封装<br><a href="https://deepxde.readthedocs.io/en/latest/demos/pinn_forward/burgers.rar.html">DeepXDE文档</a></li><li>Code参考</li></ol><div style="border: 1px solid #ccc; padding: 16px; width: 100%; max-width: 800px; margin: auto;">  <a href="https://youtube.com/watch?v=AXXnSzmpyoI&t=790s" target="_blank" style="text-decoration: none; color: inherit; display: block;">    <img src="https://img.youtube.com/vi/AXXnSzmpyoI/maxresdefault.jpg" alt="Learning Physics Informed Machine Learning Part 1- Physics Informed Neural Networks (PINNs)" style="width: auto; height: 300px; object-fit: cover;">    <h2 style="font-size: 1.5em; margin: 0.5em 0;">Learning Physics Informed Machine Learning Part 1- Physics Informed Neural Networks (PINNs)</h2>  </a></div><ol start="7"><li>限制和变种</li></ol><div style="border: 1px solid #ccc; padding: 16px; width: 100%; max-width: 800px; margin: auto;">  <a href="https://www.youtube.com/watch?v=FAfVbrufiZM'"target="_blank" style="text-decoration: none; color: inherit; display: block;">    <img src="https://img.youtube.com/vi/FAfVbrufiZM/maxresdefault.jpg" alt="Learning Physics Informed Machine Learning Part 1- Physics Informed Neural Networks (PINNs)" style="width: auto; height: 300px; object-fit: cover;">    <h2 style="font-size: 1.5em; margin: 0.5em 0;">ETH Zürich DLSC: Physics-Informed Neural Networks - Limitations and Extensions</h2>  </a></div>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试常考题目(非lc)</title>
      <link href="/posts/340249a9.html"/>
      <url>/posts/340249a9.html</url>
      
        <content type="html"><![CDATA[<h1>CNN</h1><h1>RNN</h1><h2 id="手撕">手撕</h2><h1>LSTM</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/posts/e85d694a.html"/>
      <url>/posts/e85d694a.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th>AC3</th></tr></thead><tbody><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104 二叉树的最大深度</a></td><td style="text-align:center">easy</td><td style="text-align:center">递归</td><td style="text-align:center">7.10</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/same-tree/">100 相同的树</a></td><td style="text-align:center">easy</td><td style="text-align:center">递归</td><td style="text-align:center">7.10</td><td style="text-align:center"></td><td>知道思路但不会写，xs</td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/symmetric-tree/">101 对称二叉树</a></td><td style="text-align:center">easy</td><td style="text-align:center">递归</td><td style="text-align:center">7.10</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/balanced-binary-tree/">110 平衡二叉树</a></td><td style="text-align:center">easy</td><td style="text-align:center">递归</td><td style="text-align:center">7.10</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199 二叉树的右视图</a></td><td style="text-align:center">medium</td><td style="text-align:center">递归</td><td style="text-align:center">7.15</td><td style="text-align:center"></td><td>完全没思路</td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98 验证二叉搜索树</a></td><td style="text-align:center">medium</td><td style="text-align:center">递归</td><td style="text-align:center">7.15</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236 二叉树的最近公共祖先</a></td><td style="text-align:center">medium</td><td style="text-align:center">分类+递归</td><td style="text-align:center">7.18</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">Meta题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235 二叉搜索树的最近公共祖先</a></td><td style="text-align:center">medium</td><td style="text-align:center">中序遍历</td><td style="text-align:center">7.18</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102 二叉树的层序遍历</a></td><td style="text-align:center">medium</td><td style="text-align:center">层序遍历 or 队列bfs</td><td style="text-align:center">7.21</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">亚马逊题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103 二叉树的锯齿形层序遍历</a></td><td style="text-align:center">medium</td><td style="text-align:center">层序遍历</td><td style="text-align:center">7.21</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">谷歌题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513 找树左下角的值</a></td><td style="text-align:center">medium</td><td style="text-align:center">层序遍历</td><td style="text-align:center">7.21</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230 二叉搜索树中第K小的元素</a></td><td style="text-align:center">medium</td><td style="text-align:center">中序遍历</td><td style="text-align:center">7.22</td><td style="text-align:center"></td><td>完全没思路</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107 二叉树的层序遍历 II</a></td><td style="text-align:center">medium</td><td style="text-align:center">层序遍历</td><td style="text-align:center">7.21</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"><br></td><td style="text-align:center"><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111 二叉树的最小深度</a></td><td style="text-align:center">easy</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100<br></td><td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94 二叉树的中序遍历</a></td><td style="text-align:center">easy</td><td style="text-align:center">递归</td><td style="text-align:center">7.22</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/invert-binary-tree/">226 翻转二叉树</a></td><td style="text-align:center">easy</td><td style="text-align:center">递归</td><td style="text-align:center">7.22</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108 将有序数组转换为二叉搜索树</a></td><td style="text-align:center">easy</td><td style="text-align:center">分治 构造树</td><td style="text-align:center"></td><td style="text-align:center"></td><td><strong>不会</strong></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543 二叉树的直径</a></td><td style="text-align:center">easy</td><td style="text-align:center">树形DP</td><td style="text-align:center"></td><td style="text-align:center"></td><td><strong>不会</strong></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114 二叉树展开为链表</a></td><td style="text-align:center">easy</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td><strong>不会</strong></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><h1>二叉树</h1><p>递：从原问题出发，把原问题分解为更小的子问题<br>归：递归的<strong>边界条件</strong>，直接返回它的答案</p><h1>104 二叉树的最大深度</h1><h2 id="方案1">方案1</h2><p>整棵树的最大深度 = max(左子树的最大深度，右子树的最大深度) + 1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.maxDepth(root.left)</span><br><span class="line">        right = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + <span class="number">1</span>  <span class="comment"># 加一是为了把当前节点加上</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n) 每个节点都遍历了一次<br>空间复杂度:O(n)<br>return的时候,这个节点如何知道应该return到哪个节点上去呢。需要栈来记录(最后放进去的节点最先出来)。<br>最坏情况下，这个二叉树只有左儿子，变成链，空间复杂度为O(n)</p></blockquote><h2 id="自上而下">自上而下</h2><p>另一种递归思路<br>在递归时，除了可以把节点传下去，还可以<strong>把路径上的节点个数</strong>也传下去。<br>递归的同时维护一个全局变量，每次+1后更新这个全局变量的最大值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node, cnt</span>): <span class="comment"># 节点和路径上的节点数</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            cnt += <span class="number">1</span> <span class="comment"># 加上当前节点</span></span><br><span class="line">            <span class="comment"># 全局变量 ans</span></span><br><span class="line">            <span class="keyword">nonlocal</span> ans</span><br><span class="line">            <span class="comment"># 更新ans</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cnt)</span><br><span class="line">            <span class="comment"># 更新左右子树</span></span><br><span class="line">            f(node.left, cnt)</span><br><span class="line">            f(node.right, cnt)</span><br><span class="line">            </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        f(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1>100 相同的树</h1><p>根节点是否相同，左子树、右子树是否相同<br>边界条件：两棵树有一个是空的，就无法递归了。如果两个节点都是空，就返回true。否则就是false</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">self, p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 边界条件</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># P,Q 都空，返回True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> p == q <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 当前节点的值相同，且左右子树相同</span></span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n) 每个节点都遍历了一次<br>空间复杂度:O(n)  用了栈，记录要return的节点</p></blockquote><h1>101 对称二叉树</h1><p>观察左边的右子树和右边的左子树是否相同。把轴对称问题变为上一题的子树相同问题。</p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720602126827.webp" alt="1720602126827.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isSameTree</span>(<span class="params">p: <span class="type">Optional</span>[TreeNode], q: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="comment"># 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> q <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> p == q</span><br><span class="line">    <span class="comment"># 1. 左边的左子树，右边的右子树</span></span><br><span class="line">    <span class="comment"># 2. 左边的右子树，右边的左子树</span></span><br><span class="line">    <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> isSameTree(p.left, q.right) <span class="keyword">and</span> isSameTree(p.right, q.left)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        p = root.left</span><br><span class="line">        q = root.right</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p, q)</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n) 每个节点都遍历了一次<br>空间复杂度:O(n)  用了栈，记录要return的节点</p></blockquote><h1>110 平衡二叉树</h1><p><strong>平衡二叉树</strong>：是指该树所有节点的左右子树的深度相差不超过 1。<br>边界条件：如果发现不平衡，就把-1返回给父节点。只要返回了-1就不再递归了。这里是在原始计算height的基础上加的。<br>写一个递归def, 如果左右子树的深度相差超过 1, return -1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isBalanced</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_height</span>(<span class="params">root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>    <span class="comment"># height = 0</span></span><br><span class="line">            left_h = get_height(root.left)</span><br><span class="line">            <span class="keyword">if</span> left_h == -<span class="number">1</span>: <span class="comment"># 不平衡</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            right_h = get_height(root.right)</span><br><span class="line">            <span class="keyword">if</span> right_h == -<span class="number">1</span> <span class="keyword">or</span> <span class="built_in">abs</span>(right_h - left_h) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_h, right_h) + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        ans = get_height(root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> <span class="keyword">if</span> ans == -<span class="number">1</span> <span class="keyword">else</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n) 每个节点都遍历了一次<br>空间复杂度:O(n)  用了栈，记录要return的节点</p></blockquote><h1>199 二叉树的右视图</h1><ol><li>怎么把答案记下来</li><li>怎么判断这个节点是否需要记录到答案中<br><strong>深度</strong>:在递归的同时记录一个节点个数(递归深度)，如果递归深度 = 答案长度，那么这个节点需要记录到答案中。</li></ol> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 深度 = len(ans) 记录答案</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], height</span>):</span><br><span class="line">            <span class="comment"># 先递归右子树,再递归左子树</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:    <span class="comment"># 终止条件</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> height == <span class="built_in">len</span>(ans):</span><br><span class="line">                ans.append(node.val) </span><br><span class="line">            height += <span class="number">1</span></span><br><span class="line">            f(node.right, height)</span><br><span class="line">            f(node.left, height)</span><br><span class="line">            </span><br><span class="line">        f(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n) 每个节点都遍历了一次<br>空间复杂度:O(n)  用了栈，记录要return的节点</p></blockquote><h1>98 验证二叉搜索树</h1><h2 id="前序遍历">前序遍历</h2><p>root --&gt; 左子树 --&gt; 右子树<br>需要check一下是否满足二叉搜索树的定义。<br>维护一个开区间，记录下一个递归节点的范围。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">self, x, left, right</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> left &lt; x &lt; right</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], left = -inf, right = inf </span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        x = root.val</span><br><span class="line">        <span class="keyword">return</span> self.check(x, left, right) <span class="keyword">and</span> self.isValidBST(root.left,left, x) <span class="keyword">and</span> self.isValidBST(root.right, x, right)</span><br></pre></td></tr></table></figure><h2 id="中序遍历">中序遍历</h2><p>左子树 --&gt; root --&gt; 右子树<br>基本性质：<strong>二叉搜索树的中序遍历是一个严格递增序列</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    pre = -inf</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 左子树不为空 or 当前节点值小于上一个节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.isValidBST(root.left) <span class="keyword">or</span> root.val &lt;= self.pre:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.pre = root.val</span><br><span class="line">        <span class="keyword">return</span> self.isValidBST(root.right)</span><br></pre></td></tr></table></figure><h2 id="后序遍历">后序遍历</h2><p>先遍历左右子树，在判断节点值。把节点值的范围往上传。<br>更新左子树的范围界和右子树的范围界。<br>左边反min，右边反max，全局变量记录结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> inf, -inf</span><br><span class="line">            l_min, l_max = f(node.left)</span><br><span class="line">            r_min, r_max = f(node.right)</span><br><span class="line">            x = node.val</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> x &lt;= l_max <span class="keyword">or</span> x &gt;= r_min:</span><br><span class="line">                <span class="keyword">return</span> -inf, inf        <span class="comment"># 不符合二叉搜索树条件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(l_min, x), <span class="built_in">max</span>(r_max, x)</span><br><span class="line"></span><br><span class="line">        left, right = f(root)</span><br><span class="line">        <span class="keyword">if</span> right <span class="keyword">is</span> <span class="keyword">not</span> inf:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># return f(root)[1] != inf</span></span><br></pre></td></tr></table></figure><h1>236 二叉树的最近公共祖先</h1><p><a href="https://mermaid.js.org/syntax/flowchart.html">mermaid 学习</a><br><a href="https://mermaid.live/edit#pako:eNqrVkrOT0lVslJKy8kvT85ILCpR8AmKyVMAAn-Npx1tzzfufrFuxYt1uzQhgo4aT_dOftrZ-6Kr6XnTzmcz1j9fuQvChipwQldQAJVwRpcohEr4K-jq2ik4KqgpOAGxMxC7aDxt3fZk9zSYnXApkMIX-6c8nT0P2SyIquTE4lRDjafblz3t3_x07YRnCya-bN77rHPf044N7_fMwtSlqYDQZ6TxtH_VszmdIN1grU92rEXT-rJh0tO9k-AKns9qeb578rN5c5CNMYYZA3MBTmNgCrAaY4Lhi00LgaaimYQIeKhWF3DwgIMBGFhgb0FpYyhtAlIIwko6SrmpRbmJmSnAmK8GiyqVZKTmpsYoWQGZKalpiaU5JTFKMXm1QKWJpSX5wZV5yUpWJUWlqTpKRfml6RlKVmmJOcVAXmlBSmJJqktmYnpRYi5cNDUlsyS_yBeStsBJrBYAzP0qWQ">mermaid在线测试</a><br>一个节点也可以是它自己的祖先。<br>分类讨论：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    O(分类讨论)</span><br><span class="line">    A(当前节点是空节点)</span><br><span class="line">    B(当前节点是p)</span><br><span class="line">    C(当前节点是q)</span><br><span class="line">    O --&gt; A &amp; B &amp; C &amp; D(其他)</span><br><span class="line">    A &amp; B &amp; C --&gt; 返回当前节点</span><br><span class="line">    </span><br><span class="line">    case1(左右子树都找到：返回当前节点)</span><br><span class="line">    case2(只有左子树中找到：返回递归左子树的结果)</span><br><span class="line">    case3(只有右子树中找到：返回递归右子树的结果)</span><br><span class="line">    case4(左右子树都没有找到：返回空节点)</span><br><span class="line">    D --&gt; case1 &amp; case2 &amp; case3 &amp; case4</span><br></pre></td></tr></table></figure><ol><li>如果当前节点是p or q ，那么无论q是下面的哪个节点，最近公共祖先都是当前节点；如果另一个节点不在这个子树，那这里也是返回当前节点，再return n 次 找到公共祖先。</li><li>找到如何判断：因为如果找到，则root应该为 p or q ，所以可以先递归一遍左右子树，建立stack。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root <span class="keyword">is</span> p <span class="keyword">or</span> root <span class="keyword">is</span> q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># 递归左边和右边</span></span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">elif</span> left <span class="keyword">and</span> right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">elif</span> right <span class="keyword">and</span> left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h1>235 二叉搜索树的最近公共祖先</h1><p>二叉搜索树的性质：左子树的节点值都比当前节点值小，右子树的节点值都比当前节点值大。<br>中序遍历后，得到一个递增的数组。<br>p 和 q 在哪个子树的判定： 用二叉搜索树的性质判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    O(分类讨论)</span><br><span class="line">    O1(返回当前节点)</span><br><span class="line">    N(当前节点是空节点) --&gt; 不需要判断</span><br><span class="line">N1(当前节点是p) --&gt; B(如果q小于p，那么返回p)--&gt;不可能是p下面的节点 --&gt; O1</span><br><span class="line">    N2(当前节点是q) --&gt; A(如果p小于q，那么返回q)--&gt; O1</span><br><span class="line">    Case1(p和q都在左子树中) --&gt; 返回递归左子树的结果</span><br><span class="line">    Case2(p和q都在右子树中) --&gt; 返回递归右子树的结果</span><br><span class="line">    Case3(p和q在两边中) --&gt; O1</span><br><span class="line">    O --&gt; N &amp; N1 &amp; N2 &amp; Case1 &amp; Case2 &amp; Case3   </span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        x = root.val</span><br><span class="line">        <span class="comment"># 都在左子树，递归左子树</span></span><br><span class="line">        <span class="keyword">if</span> p.val &lt; x <span class="keyword">and</span> q.val &lt; x:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="comment"># 都在右子树，递归右子树</span></span><br><span class="line">        <span class="keyword">if</span> p.val &gt; x <span class="keyword">and</span> q.val &gt; x:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1>102  二叉树的层序遍历</h1><p>逐层地，从左到右访问所有节点 : BFS</p><h2 id="双数组写法">双数组写法</h2><p>cur: 记录当前层的所有节点<br>nxt: 记录下一层的所有节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cur = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nxt = []</span><br><span class="line">            values = []</span><br><span class="line">            <span class="comment"># 对于cur中每一个结点，依次放入其左右子树</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> cur:</span><br><span class="line">                values.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: nxt.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: nxt.append(node.right)</span><br><span class="line">            ans.append(values)</span><br><span class="line">            cur = nxt</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="单队列-bfs">单队列(bfs)</h2><p>用deque()模拟双端队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = deque([root])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 队列不为空</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            values = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                <span class="comment"># 咋取出来第一个元素</span></span><br><span class="line">                <span class="comment"># 左进右出</span></span><br><span class="line">                node = q.popleft()</span><br><span class="line">                values.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            ans.append(values)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1>103 二叉树的锯齿形层序遍历</h1><p>锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 给一个bool变量记录奇偶层</span></span><br><span class="line">        ou = <span class="literal">False</span> <span class="comment"># 奇数层</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        cur = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            nxt = []</span><br><span class="line">            values = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> cur:</span><br><span class="line">                values.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left: nxt.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: nxt.append(node.right)</span><br><span class="line">            <span class="comment"># 偶数层对values进行翻转</span></span><br><span class="line">            values = values[::-<span class="number">1</span>] <span class="keyword">if</span> ou <span class="keyword">else</span> values</span><br><span class="line">            ans.append(values)</span><br><span class="line">            cur = nxt</span><br><span class="line">            ou = <span class="keyword">not</span> ou  <span class="comment"># 第2层为偶数</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1>513 找树左下角的值</h1><h2 id="bfs层序遍历-（从右到左遍历的最后一个）">bfs层序遍历 （从右到左遍历的最后一个）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">None</span></span><br><span class="line">        q = deque([root])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> node.val</span><br></pre></td></tr></table></figure><h2 id="dfs递归（左视图）">dfs递归（左视图）</h2><p>如果答案数组长度 = 数的深度，则记录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="comment"># 递归dfs</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node: <span class="type">Optional</span>[TreeNode], height</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ans) == height:</span><br><span class="line">                ans.append(node.val)</span><br><span class="line">            <span class="comment"># height += 1</span></span><br><span class="line">            <span class="comment"># 先左子树，后右子树，保证记录的是左视图</span></span><br><span class="line">            f(node.left, height + <span class="number">1</span>)</span><br><span class="line">            f(node.right, height + <span class="number">1</span>)</span><br><span class="line">        f(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1>107. 二叉树的层序遍历 II</h1><p>给你二叉树的根节点 root，返回其节点值自底向上的层序遍历。<br><strong>按原先的记录每一层后，然后反转ans[: : -1]</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = deque([root])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            values = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(q)):</span><br><span class="line">                node = q.popleft()</span><br><span class="line">                values.append(node.val)</span><br><span class="line">                <span class="comment"># 左子树，右子树</span></span><br><span class="line">                <span class="keyword">if</span> node.left: q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: q.append(node.right)</span><br><span class="line">            ans.append(values)</span><br><span class="line">        <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h1>94 二叉树的中序遍历</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 递归</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            f(node.left)</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            f(node.right)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        f(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n) 每个节点都遍历了一次<br>空间复杂度:O(n)  用了栈，记录要return的节点</p></blockquote><h1>226 翻转二叉树</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">        <span class="comment"># 对于每一颗子树，交换其左右子树</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            tmp = f(node.left)</span><br><span class="line">            node.left = f(node.right)</span><br><span class="line">            node.right = tmp</span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">        f(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure><h1>108 将有序数组转换为二叉搜索树</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1>230. 二叉搜索树中第K小的元素</h1><p>正常做中序遍历，遍历完后取第k小的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node, k</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span>  <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            f(node.left, k)</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            f(node.right, k)</span><br><span class="line">            <span class="comment"># 第k小的元素</span></span><br><span class="line">            <span class="keyword">if</span> k &lt;= <span class="built_in">len</span>(ans):</span><br><span class="line">                <span class="keyword">return</span> ans[k-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        ans = f(root, k)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>按中序遍历得到最小的，然后提前终止</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kthSmallest</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 按中序遍历得到最小的，然后提前终止</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            f(node.left)</span><br><span class="line">            self.k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.k == <span class="number">0</span>:</span><br><span class="line">                self.ans = node.val</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            f(node.right)</span><br><span class="line"></span><br><span class="line">        self.k = k</span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        f(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/posts/e8eb0481.html"/>
      <url>/posts/e8eb0481.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th></th></tr></thead><tbody><tr><td style="text-align:center">hot100(模板题)</td><td style="text-align:center"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34 在排序数组中查找元素的第一个和最后一个位置</a></td><td style="text-align:center">medium</td><td style="text-align:center">二分查找</td><td style="text-align:center">7.07</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">Meta题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/find-peak-element/description/">162 寻找峰值</a></td><td style="text-align:center">medium</td><td style="text-align:center">二分查找</td><td style="text-align:center">7.08</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">153 寻找旋转排序数组中的最小值 - 力扣（LeetCode）</a></td><td style="text-align:center">medium</td><td style="text-align:center">二分查找</td><td style="text-align:center">7.08</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33 搜索旋转排序数组</a></td><td style="text-align:center">medium</td><td style="text-align:center">二分查找(很巧妙)</td><td style="text-align:center">7.09</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><h1>基本思想</h1><h2 id="左闭右闭区间">左闭右闭区间</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720352690230.webp" alt="1720352690230.png"><br>mid &lt; 8, 答案在右半区间, 更新左端点 L=M+1<br>mid &gt;= 8，第一个&gt;=8的数字在左半区间，更新右端点 R = M-1<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720353219440.webp" alt="1720353219440.png"></p><ol><li>第一个 &gt;= target 的值，应用循环不变量，得到最终应该返回的答案是 L 还是 R</li><li>如果所有元素都 &lt; 8, L 一直向右移动，移动到R的右边，L = len(nums), L-1仍然始终是红色</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [ ]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lowbound</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># [left, right] left 和 right 应该都能取到</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:            <span class="comment"># 区间不为空，继续循环</span></span><br><span class="line">        <span class="comment"># left + (right - left)//2  # 先减后加，防止溢出</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span>   <span class="comment"># 下取整</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment"># [mid + 1, right]</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span> <span class="comment"># [left, mid - 1]</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><h2 id="左闭右开区间">左闭右开区间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [ )</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lowbound</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)      <span class="comment"># [left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:             <span class="comment"># 区间不为空，继续循环</span></span><br><span class="line">    <span class="comment"># l = r 时区间就空了, [left, left) 是矛盾的</span></span><br><span class="line">        <span class="comment"># left + (right - left)//2  # 先减后加，防止溢出</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span>   <span class="comment"># 下取整</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span> <span class="comment"># [mid + 1, right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid <span class="comment"># [left, mid - 1] = [left, mid)</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># l和R都指向答案</span></span><br></pre></td></tr></table></figure><h2 id="左开右开区间">左开右开区间</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ( )</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lowbound3</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    left, right = -<span class="number">1</span> , <span class="built_in">len</span>(nums)      <span class="comment"># (left, right)</span></span><br><span class="line">    <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:             <span class="comment"># 区间不为空，继续循环</span></span><br><span class="line">    <span class="comment"># l+1 = r 时区间就空了, （left, left) 是矛盾的</span></span><br><span class="line">        <span class="comment"># left + (right - left)//2  # 先减后加，防止溢出</span></span><br><span class="line">        mid = (left + right) // <span class="number">2</span>   <span class="comment"># 下取整</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid  <span class="comment"># [mid + 1, right) = (mid, right)</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid <span class="comment"># [left, mid - 1] = [left, mid)</span></span><br><span class="line">    <span class="keyword">return</span> right  <span class="comment"># l+1和R都指向答案</span></span><br></pre></td></tr></table></figure><h2 id="其他关系转化">其他关系转化</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720362429364.webp" alt="1720362429364.png"></p><h1>34 在排序数组中查找元素的第一个和最后一个位置</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        start = lowbound(nums, target)</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) <span class="keyword">or</span> nums[start] != target:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># &lt;= , 即为 &gt; (x+1)的第一个数字 - 1</span></span><br><span class="line">        end = lowbound3(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(logn)<br>空间复杂度:O(1)</p></blockquote><h1>162 寻找峰值</h1><p>峰值元素是指其值严格大于左右相邻值的元素。最重要的是找到循环不变量<br>在本题中， left - 1 始终是红色，right + 1始终是蓝色，表示峰顶及右边的元素<br>比较mid 及后一个元素，更新mid</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findPeakElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 红色 峰顶左边的元素</span></span><br><span class="line">        <span class="comment"># 蓝色 峰顶 及 右边的元素</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>  <span class="comment"># [ ]</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right: <span class="comment"># 当right移到left左边时，区间为空，停止循环</span></span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid + <span class="number">1</span>]: <span class="comment"># mid 一定在峰顶左边 [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(logn)<br>空间复杂度:O(1)</p></blockquote><h1>153 寻找旋转排序数组中的最小值</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMin</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 红色： false 最小值左侧     染红色，更新left</span></span><br><span class="line">        <span class="comment"># 蓝色： true 最小值及其右侧  染蓝色，更新right</span></span><br><span class="line">        <span class="comment"># 最后一个数，要么是最小值，要么在最小值右侧</span></span><br><span class="line">        <span class="comment"># n - 1必然是蓝色</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span> <span class="comment"># [0, n-2]</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right ) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>]: <span class="comment"># 染蓝色，更新right</span></span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums[left]</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(logn)<br>空间复杂度:O(1)</p></blockquote><h1>33 搜索旋转排序数组</h1><h2 id="两次二分">两次二分</h2><ol><li>找到最小值</li><li>比较 target 与 nums[-1] 的大小关系，在左边段或者右边二分查找 target<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720497270384.webp" alt="1720497270384.png"></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">findlittle</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="comment"># 最小值 ：红色 false 最小值左边 更新 left</span></span><br><span class="line">    <span class="comment">#         蓝色 true 最小值及其右边 right</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">2</span>  <span class="comment"># [0, n-2]</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right :</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; nums[<span class="built_in">len</span>(nums) - <span class="number">1</span>]: <span class="comment"># 蓝色</span></span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left  <span class="comment"># 返回第二个递增数组的0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span>, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt;<span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = (left + right) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nums[left] == target:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先找到最小值，从最小值处分成两个递增的数组，然后二分分别查找左右两边有没有target</span></span><br><span class="line">        lit = findlittle(nums)</span><br><span class="line">        <span class="keyword">if</span> target &gt; nums[-<span class="number">1</span>] :                   <span class="comment"># 画图发现能分开</span></span><br><span class="line">            <span class="keyword">return</span> find(nums, target, <span class="number">0</span>, lit - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> find(nums, target, lit, <span class="built_in">len</span>(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(logn)<br>空间复杂度:O(1)</p></blockquote><h2 id="单次二分">单次二分</h2><p>循环不变量<br>红色   二分位置 nums[mid] 在 target 左侧<br>蓝色： 二分位置 nums[mid] 在 target 及其右侧</p><h3 id="情况1">情况1</h3><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720516268352.webp" alt="1720516268352.png"></p><h3 id="情况2">情况2</h3><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720516278770.webp" alt="1720516278770.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_bule</span>(<span class="params">i: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">            end = nums[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; end:</span><br><span class="line">                <span class="keyword">return</span> target &gt; end <span class="keyword">and</span> nums[i] &gt;= target</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> target &gt; end <span class="keyword">or</span> nums[i] &gt;= target</span><br><span class="line">                </span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> is_bule(mid):</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> nums[left] == target <span class="keyword">else</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口</title>
      <link href="/posts/50cab45.html"/>
      <url>/posts/50cab45.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><p>参考<a href="https://leetcode.cn/circle/discuss/0viNMK/">灵神题单</a><br><a href="https://github.com/EndlessCheng/codeforces-go/blob/master/leetcode/README.md">代码参考</a></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th>AC3</th></tr></thead><tbody><tr><td style="text-align:center">Meta题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></td><td style="text-align:center">medium</td><td style="text-align:center">滑动窗口</td><td style="text-align:center">7.06</td><td style="text-align:center"></td><td>完全没见过的思路，多刷一遍</td></tr><tr><td style="text-align:center">Meta题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></td><td style="text-align:center">medium</td><td style="text-align:center">滑动窗口</td><td style="text-align:center">7.06</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">字节题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td><td style="text-align:center">medium</td><td style="text-align:center">滑动窗口</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">2958</td><td style="text-align:center">``</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">2730</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">2779</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1004</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">2962</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">2302</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1658</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center">76</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">只有满足了单调性，才可以使用双指针</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><h1>209 长度最小的子数组</h1><p>分析：</p><ol><li>暴力做法：枚举左端点，不断向右扩展，求sum，直到达到target为止。也可以枚举右端点，不断向左扩展，直到达到target为止。暴力的时间复杂度是O($N^2$)的，1 &lt;= nums.length &lt;= 105，不满足要求。</li><li>因为要连续子数组，所以不能排序。</li><li>枚举右端点，在原先满足s &gt;= target的情况下缩短左端点。</li><li>特例化：带入left = right，判断是不是要+1</li><li>时间复杂度分析：left += 1的次数最多是n次，left 不会重置。时间复杂度应该是 left += 1的次数以及 right += 1 的次数，都是n次，所以O(N)，因为不会重复加</li></ol><blockquote><p>left 移动时，子数组的和不断变小。while条件从<strong>满足要求</strong>不断地变为<strong>不满足要求</strong>。满足单调性。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = inf <span class="comment"># 初始化为无穷大</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 枚举右端点</span></span><br><span class="line">        <span class="keyword">for</span> right, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            s += x     <span class="comment"># x = num[right]</span></span><br><span class="line">            <span class="comment"># 不需要判断 left &lt;= right ,因为符合条件时,left才会右移，和713不一样</span></span><br><span class="line">            <span class="keyword">while</span> s &gt;= target:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right - left + <span class="number">1</span>)</span><br><span class="line">                s -= nums[left]</span><br><span class="line">                <span class="comment"># 左端点右移，减小符合条件的区间</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> ans &lt;= <span class="built_in">len</span>(nums) <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>空间复杂度:O(1)</p></blockquote><h1>713 乘积小于K的子数组</h1><blockquote><p>while条件从<strong>不满足要求</strong>不断地变为<strong>满足要求</strong>。满足单调性。<br>如果元素的乘积 &gt;= k, 左端点右移，缩小子数组的长度，直到 &lt; k 为止</p></blockquote><p>思路：</p><ol><li>假设 [l, r]的元素乘积 &lt; k，则[l, r],[l+1, r], …,[r,r]的 r-l+1个子数组的元素乘积均 &lt; k。</li><li>r - l + 1 这里需不需要 + 1 ？若 r = l , 则 [r, r] 应满足条件，故应该 + 1</li><li>特判: k &lt;= 1，不存在严格 &lt; k 的乘积，return 0</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSubarrayProductLessThanK</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        prob = <span class="number">1</span> <span class="comment"># 乘积</span></span><br><span class="line">        ans = <span class="number">0</span>  <span class="comment"># 记录个数</span></span><br><span class="line">        <span class="comment"># 枚举右端点</span></span><br><span class="line">        <span class="keyword">for</span> right, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            prob *= x</span><br><span class="line">            <span class="comment"># 需要加 left &lt;= right 条件，因为当left = right 时，porb 不一定严格 &lt; k;主要是存在特例 k=0 or k=1 不存在严格小于k的</span></span><br><span class="line">            <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> prob &gt;= k:  <span class="comment"># 找个 &lt; k的边界，然后用规律计算个数</span></span><br><span class="line">            <span class="comment"># 规律: 若[l, r]的乘积 &lt; k</span></span><br><span class="line">            <span class="comment"># 那么[l,r],[l+1,r],...[r,r] 这 r-l+1 个子数组都 &lt; k</span></span><br><span class="line">                prob = prob / nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            ans += right - left + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>空间复杂度:O(1)</p></blockquote><h1>3 无重复字符的最长子串</h1><blockquote><p>单调性：有重复元素 --&gt; 无重复元素<br>例如:‘abc’无重复元素，右端点右移得到’abcb’,有重复元素，开始移动左端点，一直到没有重复元素位置。</p></blockquote><ol><li>每次接入新的元素时，都是接入到一个没有重复的子串后面。所以如果有重复，那一定来自新接入的元素。</li><li>用 hashmap 记录字符的出现次数 ，key : char, value : int</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex环境配置与基础命令</title>
      <link href="/posts/c0973ef2.html"/>
      <url>/posts/c0973ef2.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://texdoc.org/serve/lshort-zh-cn.pdf/0">Latex2e文档</a><br><a href="https://andy123t.github.io/2020/09/22/LaTeX-Figure/">Latex插图</a></p><h1>环境配置</h1><h1>基础操作</h1><h2 id="数学公式">数学公式</h2><h3 id="eqution">eqution</h3><p>用于<strong>单个</strong>需要编号的方程。</p><ul><li>自动为方程编号。</li><li>默认居中对齐方程。</li><li>只适用于单行方程（尽管可以通过 <code>\\</code> 强制换行，但这不是最佳实践）。</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">  E = mc<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><h3 id="align">align</h3><p>用于<strong>多个</strong>需要对齐的方程，通常用于方程组或推导步骤。</p><ul><li>允许在特定位置（例如等号 <code>=</code>）对齐方程。</li><li>每行都可以编号。</li><li>需要 <code>amsmath</code> 宏包。</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line">  E <span class="built_in">&amp;</span>= mc<span class="built_in">^</span>2 <span class="keyword">\\</span></span><br><span class="line">  F <span class="built_in">&amp;</span>= ma</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br></pre></td></tr></table></figure><h2 id="表格">表格</h2><p>表格处理工具：<br><a href="http://www.tablesgenerator.com/">LaTeX Tables Generator</a></p><h1>伪代码</h1><p><a href="https://library.xmu.edu.cn/__local/7/CA/C2/CD6FA51F6F2B6C6A098FB3D1A43_17A1EC69_BCA2F.pdf?e=.pdf">我的 LaTeX使用体会 (xmu.edu.cn)</a></p><p><a href="https://welts.xyz/2022/01/17/pseudocode/">伪代码教学</a></p><p><a href="https://inkscape.org/">inkscape学习</a></p><p><a href="https://kz16.top/na/plot/">matplotlib绘图经验</a></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/posts/91a7e4d1.html"/>
      <url>/posts/91a7e4d1.html</url>
      
        <content type="html"><![CDATA[<h1>题单</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th><th>AC3</th></tr></thead><tbody><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/3sum/">15 三数之和</a></td><td style="text-align:center">medium</td><td style="text-align:center">相向双指针</td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167 两数之和 II - 输入有序数组</a></td><td style="text-align:center">medium</td><td style="text-align:center">相向双指针</td><td style="text-align:center">7.04</td><td style="text-align:center"></td><td>第一遍完全没思路</td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/container-with-most-water/">11 盛最多水的容器</a></td><td style="text-align:center">medium</td><td style="text-align:center">相向双指针</td><td style="text-align:center">7.05</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/trapping-rain-water/">42 接雨水</a></td><td style="text-align:center">hard</td><td style="text-align:center">前缀 or 相向双指针</td><td style="text-align:center">7.06</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/move-zeroes/">283 移动零</a></td><td style="text-align:center">easy</td><td style="text-align:center"></td><td style="text-align:center">7.06</td><td style="text-align:center"></td><td></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table><h1>167 两数之和 II - 输入有序数组</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, numbers: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 题目要求index1 &lt; index2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            sum1 = numbers[left] + numbers[right]</span><br><span class="line">            <span class="keyword">if</span> sum1 == target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> sum1 &gt; target:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [left + <span class="number">1</span>, right + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>空间复杂度: O(1))</p></blockquote><h1>15 三数之和</h1><p>完全没思路</p><ol><li>遍历 i 下标，因为 nums[i] + nums[j] + nums[k] = 0, 所以nums[j] + nums[k] = -nums[i]</li><li>答案中不可以包含重复的三元组  ： nums[i]的值不重复</li><li>究极bug的用例[0,0,0,0],这个用例中i, j, k的值都可能会重复</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 注意，输出的顺序和三元组的顺序并不重要</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        inums = <span class="built_in">set</span>()</span><br><span class="line">        <span class="comment"># 不重复</span></span><br><span class="line">        <span class="comment"># ans = set()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># i != j、i != k 且 j != k  --&gt; i &lt; j &lt; k</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> inums:</span><br><span class="line">            inums.add(nums[i])</span><br><span class="line">            target = - nums[i]</span><br><span class="line">            j = i + <span class="number">1</span></span><br><span class="line">            k = <span class="built_in">len</span>(nums)- <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[j] + nums[k]</span><br><span class="line">                <span class="keyword">if</span> s == target:</span><br><span class="line">                    ans.append([nums[i], nums[j], nums[k]])</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> s &gt; target:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h1>11 盛最多水的容器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> height[right] &lt; height[left]:</span><br><span class="line">                s = (right - left) * height[right]</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, s)</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = (right - left) * height[left]</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, s)</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)  每次移动指针只花费了O(1)的时间，所有指针移动的距离加起来是O(N)的<br>空间复杂度: O(1))</p></blockquote><p>小优化：<br>在移动指针后，可以判断下新的线条高度与原来的线条高度哪个长。如果新的比较短则继续移动(while)</p><h1>42 接雨水</h1><h2 id="前缀和后缀">前缀和后缀</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720229781077.webp" alt=""></p><p>前缀pre 表示这个柱子左边能够挡住的最大高度<br>后缀suf 表示这个柱子右边能够挡住的最大高度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># PRE[0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3]</span></span><br><span class="line">        <span class="comment"># SUF[3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 1]</span></span><br><span class="line">        <span class="comment"># MIN[0, 1, 1, 2, 2, 2, 2, 3, 2, 2, 2, 1]</span></span><br><span class="line">        <span class="comment"># HEI[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]</span></span><br><span class="line">        <span class="comment"># ANS[0, 0, 1, 0, 1, 2, 1, 0, 0, 1, 0, 0] # 值为6</span></span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        pre = [<span class="number">0</span>] * n</span><br><span class="line">        pre[<span class="number">0</span>] = height[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(height)):</span><br><span class="line">            pre[i] = <span class="built_in">max</span>(pre[i-<span class="number">1</span>], height[i])</span><br><span class="line"></span><br><span class="line">        suf = [<span class="number">0</span>] * n</span><br><span class="line">        suf[-<span class="number">1</span>] = height[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            suf[i] = <span class="built_in">max</span>(suf[i+<span class="number">1</span>], height[i])</span><br><span class="line"></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans += (<span class="built_in">min</span>(pre[i], suf[i]) - height[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>空间复杂度: O(n))</p></blockquote><p>时间上已经最优，但是空间上仍有优化空间。</p><h2 id="双指针">双指针</h2><p>==这个解法不会==<br>能把空间复杂度优化到O(1)<br>需要明确一些新的性质<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720231489731.webp" alt=""></p><ol><li>如果前缀最大值比后缀最大值小，那么木桶的容量就是前缀最大值。</li><li>反之，<br>用相向双指针模拟，每次移动指针只用了O(1)的时间。</li></ol><h1>283 移动零</h1><p>思路：起始时刻，快慢指针均指向0，slow指针找到0的位置，fast指针指向0后第一个非0元素的位置<br>当slow == fast时，表示所有0元素全被找到，数组的后续元素都更新为0<br>要求，不复制数组，原地， 即不能增加现有的数组长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 找非0元素</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/posts/a4ce31d2.html"/>
      <url>/posts/a4ce31d2.html</url>
      
        <content type="html"><![CDATA[<h1>455.分发饼干</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 排序后删除g中最大，且小于某个s的值</span></span><br><span class="line">        <span class="comment"># 排序O(nlogn),下面遍历O(n)</span></span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        index = <span class="built_in">len</span>(s) - <span class="number">1</span>  <span class="comment"># 饼干</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        j = <span class="built_in">len</span>(g) -<span class="number">1</span>     <span class="comment"># 孩子</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> index &gt;=<span class="number">0</span> <span class="keyword">and</span> (g[j] &lt;= s[index]) :</span><br><span class="line">                index -= <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h1>376.摆动序列</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        prediff, curdiff = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span> (<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            curdiff = nums[i+<span class="number">1</span>] - nums[i]</span><br><span class="line">            <span class="keyword">if</span>(prediff &gt;= <span class="number">0</span> <span class="keyword">and</span> curdiff &lt; <span class="number">0</span>) <span class="keyword">or</span> (prediff &lt;= <span class="number">0</span> <span class="keyword">and</span> curdiff &gt; <span class="number">0</span>):</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">                prediff = curdiff</span><br><span class="line">        <span class="comment"># res记录的差分序列</span></span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span></span><br></pre></td></tr></table></figure><h1>53. 最大子数组和</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 局部最优：当sum 为负值时，直接舍弃以此起始的i</span></span><br><span class="line">        count, res = <span class="number">0</span>, -<span class="number">10010</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            count += nums[i]</span><br><span class="line">            <span class="keyword">if</span> count &gt; res :</span><br><span class="line">                res = count</span><br><span class="line">            <span class="keyword">if</span> count &lt; <span class="number">0</span> : count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tabular Method</title>
      <link href="/posts/3e597221.html"/>
      <url>/posts/3e597221.html</url>
      
        <content type="html"><![CDATA[<ul><li>[ ] 没总结完</li></ul><h1>有模型与无模型</h1><h1>Q表格</h1><h1>无模型预测</h1><h1>无模型控制</h1>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL_note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/posts/2362a8ea.html"/>
      <url>/posts/2362a8ea.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目来自Leetcode Hot100 + 代码随想录<br>Leetcode100(14个)</p></blockquote><h1>题单</h1><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">题目</th><th style="text-align:center">难度</th><th style="text-align:center">标签</th><th style="text-align:center">AC1</th><th style="text-align:center">AC2</th></tr></thead><tbody><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=study-plan-v2&amp;envId=top-100-liked">106 相交链表</a></td><td style="text-align:center">easy</td><td style="text-align:center">哈希 or 妙</td><td style="text-align:center">6.28</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&amp;envId=top-100-liked">206 反转链表</a></td><td style="text-align:center">easy</td><td style="text-align:center">迭代 or 对向双指针</td><td style="text-align:center">6.28</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/palindrome-linked-list/">234 回文链表</a></td><td style="text-align:center">easy</td><td style="text-align:center">快慢指针</td><td style="text-align:center">6.28</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/linked-list-cycle/">141 环形链表</a></td><td style="text-align:center">easy</td><td style="text-align:center">快慢指针</td><td style="text-align:center">7.02</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">模板题</td><td style="text-align:center"><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876 链表的中间结点</a></td><td style="text-align:center">easy</td><td style="text-align:center">快慢指针</td><td style="text-align:center">7.02</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142 环形链表 II</a></td><td style="text-align:center">medium</td><td style="text-align:center">快慢指针</td><td style="text-align:center">7.03</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">字节题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/reorder-list/">143 重排链表</a></td><td style="text-align:center">medium</td><td style="text-align:center">快慢指针(876+206)</td><td style="text-align:center">7.03</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">字节题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/reverse-linked-list-ii/">92 反转链表 II</a></td><td style="text-align:center">medium</td><td style="text-align:center">对向双指针</td><td style="text-align:center">7.03</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">字节题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25 K 个一组翻转链表</a></td><td style="text-align:center">Hard</td><td style="text-align:center">对向双指针</td><td style="text-align:center">7.03</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">亚马逊题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">237 删除链表中的节点</a></td><td style="text-align:center">medium</td><td style="text-align:center">脑筋急转弯</td><td style="text-align:center">7.04</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19 删除链表的倒数第 N 个结点</a></td><td style="text-align:center">medium</td><td style="text-align:center">双指针</td><td style="text-align:center">7.04</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">字节题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83 删除排序链表中的重复元素</a></td><td style="text-align:center">easy</td><td style="text-align:center"></td><td style="text-align:center">7.04</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">美团题单</td><td style="text-align:center"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82 删除排序链表中的重复元素 II</a></td><td style="text-align:center">medium</td><td style="text-align:center">巧妙套循环</td><td style="text-align:center">7.04</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">hot100</td><td style="text-align:center"><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21 合并两个有序链表</a></td><td style="text-align:center">easy</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h1>106 相交链表</h1><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt=""></p><h2 id="暴力解法">暴力解法</h2><p>对于A中每一个node，从headB开始循环B中的每一个node，如果指针A和B的next相同，则输出指针B。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        A = headA</span><br><span class="line">        <span class="keyword">while</span> A:</span><br><span class="line">            B = headB</span><br><span class="line">            <span class="keyword">while</span> B:</span><br><span class="line">                <span class="keyword">if</span> A == B:</span><br><span class="line">                    <span class="keyword">return</span> B</span><br><span class="line">                B = B.<span class="built_in">next</span></span><br><span class="line">            A = A.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><blockquote><p>时间超限，未AC<br>时间复杂度: O($n^2$)<br>$-1 &lt;= m, n &lt;= 3 * 10^4$, 故$O(n^2)=10^8&gt;10^7$<br>空间复杂度:O(1);      只用了两个指针O(1)+O(1)</p></blockquote><h2 id="哈希表">哈希表</h2><p>把A的每一个node存入hash中，对于B的每一个node，在哈希表中查找，如果有，则输出指针B。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        s = <span class="built_in">set</span>()</span><br><span class="line">        A, B = headA, headB</span><br><span class="line">        <span class="keyword">while</span> A:</span><br><span class="line">            s.add(A)</span><br><span class="line">            A = A.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> B:</span><br><span class="line">            <span class="keyword">if</span> B <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">return</span> B</span><br><span class="line">            B = B.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>分析：存表O(n)+B节点循环O(n)+查表O(1)<br>空间复杂度:O(n);      指针O(1)+set O(n)</p></blockquote><h2 id="栈-从后往前">栈(从后往前)</h2><p>从后往前，A和B公共结点及其后面的结点完全一致。所以只需找到第一个不相同结点的下一个结点即为所求。<br>分别用两个list模拟栈，从后往前遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        A, B = headA, headB</span><br><span class="line">        <span class="keyword">while</span> A:</span><br><span class="line">            s1.append(A)</span><br><span class="line">            A = A.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> B:</span><br><span class="line">            s2.append(B)</span><br><span class="line">            B = B.<span class="built_in">next</span></span><br><span class="line">        i, j = <span class="built_in">len</span>(s1) - <span class="number">1</span>, <span class="built_in">len</span>(s2) - <span class="number">1</span></span><br><span class="line">        ans = A   <span class="comment"># ans = None</span></span><br><span class="line">        <span class="comment"># 这里开始令ans = 0为啥不行？</span></span><br><span class="line">        <span class="comment"># 因为需要return的是ListNode，不是int 类型</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> s1[i] == s2[j]:</span><br><span class="line">            ans = s1[i]</span><br><span class="line">            i, j = i-<span class="number">1</span>, j-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>分析：栈构建O(n)+O(n)+查找O(n)<br>空间复杂度:O(n);      指针O(1)+list O(n)</p></blockquote><h2 id="走过彼此的路">走过彼此的路</h2><p><strong>两个链表长度和相同</strong><br><img src="https://pic.leetcode-cn.com/1615224578-EBRtwv-Picture1.png" alt=""></p><ul><li>如果 <code>A</code> 不是空 (<code>None</code>)，则将 <code>A</code> 更新为 <code>A.next</code>，即 <code>A</code> 指向下一个节点。</li><li>如果 <code>A</code> 是空 (<code>None</code>)，则将 <code>A</code> 更新为 <code>headB</code>，即 <code>A</code> 指向另一个链表 <code>headB</code> 的头节点。<br>具体过程：<br><img src="https://pic.leetcode-cn.com/1615224578-fyOdzW-Picture8.png" alt=""></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        A, B = headA, headB</span><br><span class="line">        <span class="keyword">while</span> A != B:</span><br><span class="line">            A = A.<span class="built_in">next</span> <span class="keyword">if</span> A <span class="keyword">else</span> headB</span><br><span class="line">            B = B.<span class="built_in">next</span> <span class="keyword">if</span> B <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(a+b) A和B的链表长度<br>分析：最坏情况A从headA走到Null，然后回到headB,再走到Null<br>空间复杂度:O(n);      指针O(1)+list O(n)</p></blockquote><h1>206 反转链表</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><ul><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li><li>O($n^2$)<br>参考<a href="https://leetcode.cn/problems/reverse-linked-list/solutions/2361282/206-fan-zhuan-lian-biao-shuang-zhi-zhen-r1jel/">题解</a></li></ul><h2 id="迭代-双指针">迭代(双指针)</h2><p><img src="https://pic.leetcode-cn.com/1604779288-jExDGV-Picture3.png" alt=""><br>最终状态：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1719978860535.webp" alt="1719978860535.png"><br>反转结束后，从原来的链表上看</p><ol><li>pre指向反转这一段的末尾<br>2。 cur指向反转这一段后续的下一个节点</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        cur, pre = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span>  <span class="comment"># 暂存后继节点 cur.nex</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre  <span class="comment"># 更新反转链表的头节点</span></span><br><span class="line">            pre = cur       <span class="comment"># 更新</span></span><br><span class="line">            cur = tmp       <span class="comment"># 更新当前处理节点</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)     循环次数，链表长度<br>空间复杂度: O(1);     两个指针</p></blockquote><h2 id="递归">递归</h2><p>当越过尾节点后终止递归，在回溯时修改各节点的 <code>next</code> 引用指向。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">cur, pre</span>):</span><br><span class="line">            <span class="keyword">if</span> cur == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> pre</span><br><span class="line">            res = recur(cur.<span class="built_in">next</span>, cur)  <span class="comment"># 递归</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre              <span class="comment"># 修改节点指向</span></span><br><span class="line">            <span class="keyword">return</span> res                  <span class="comment"># 递归反转链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> recur(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)     链表长度<br>空间复杂度: O(n);    遍历链表的递归深度达到 N ，系统使用 O(N) 大小额外空间。</p></blockquote><h1>92 反转链表Ⅱ</h1><p>反转链表中间从left到right的节点</p><h2 id="双指针">双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 找到left的上一个节点</span></span><br><span class="line">        <span class="comment"># p0 = ListNode(next = head)</span></span><br><span class="line">        <span class="comment"># 更加规整的写法</span></span><br><span class="line">        <span class="comment"># 初始化哨兵节点，dummy.next = head</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        p0 = dummy</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            p0 = p0.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># p0 记录反转这一段的上一个节点</span></span><br><span class="line">        cur, pre = p0.<span class="built_in">next</span>, <span class="literal">None</span></span><br><span class="line">        <span class="comment"># for _ in range(right): # 这里写错了</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left + <span class="number">1</span>):</span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="comment"># 此时cur指向这一段节点的下一个节点</span></span><br><span class="line">        <span class="comment"># pre为相对原始链表的末尾</span></span><br><span class="line">        p0.<span class="built_in">next</span>.<span class="built_in">next</span> = cur</span><br><span class="line">        p0.<span class="built_in">next</span> = pre</span><br><span class="line">        <span class="comment"># return head</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)     链表长度<br>空间复杂度: O(n);    遍历链表的递归深度达到 N ，系统使用 O(N) 大小额外空间。</p></blockquote><h1>25 K个一组翻转链表</h1><h2 id="思路">思路</h2><ol><li>不足k个不能反转，所以应该先求出链表的长度。翻转之前，判断剩余节点的个数，&gt;=k允许反转。</li><li>p0需要更新</li><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        p0 = dummy</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 计算链表的长度</span></span><br><span class="line">        i = head</span><br><span class="line">        <span class="keyword">while</span> i:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            i = i.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 剩余节点 &gt;= k</span></span><br><span class="line">        <span class="keyword">while</span> length &gt;= k:</span><br><span class="line">            nxt = p0.<span class="built_in">next</span></span><br><span class="line">            cur, pre = p0.<span class="built_in">next</span>, <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 反转k个</span></span><br><span class="line">            <span class="comment"># while cur:</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                tmp = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = tmp</span><br><span class="line">            <span class="comment"># 连接</span></span><br><span class="line">            <span class="comment"># 这里的次序非常重要</span></span><br><span class="line">            p0.<span class="built_in">next</span>.<span class="built_in">next</span> = cur</span><br><span class="line">            p0.<span class="built_in">next</span> = pre</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 更新</span></span><br><span class="line">            length -= k</span><br><span class="line">            p0 = nxt</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1>234 回文链表</h1><p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><ul><li>链表中节点数目在范围<code>[1, 105]</code> 内</li><li>只能用O(n)和O(nlogn)的方案</li></ul><h2 id="一般双指针">一般双指针</h2><p>先做一遍反转链表，然后比较两个链表 O(N) + O(N)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        h =head</span><br><span class="line">        <span class="comment"># 复制下原始链表</span></span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            s1.append(h.val)</span><br><span class="line">            h = h.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 反转链表</span></span><br><span class="line">        cur, pre = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="comment"># 复制新链表的值</span></span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            s2.append(pre.val)</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 比较原始链表与反转链表的值，完全一致，True</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= <span class="built_in">len</span>(s1)-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> s1[i] != s2[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)     链表长度<br>复制O(n)+反转O(n)+遍历O(n)<br>空间复杂度: O(n);    两个list O(n), 2个指针</p></blockquote><h2 id="快慢指针">快慢指针</h2><p>用快慢指针找到中间节点，然后反转前半部分链表。比较前半部分和后半部分，可以将空间复杂度优化到O(1)。</p><h1>141 环形链表</h1><h2 id="快慢指针-2">快慢指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>慢指针进入环后，循环的次数小于环的长度，所以O(n)<br>空间复杂度: O(1);  只用到若干额外变量</p></blockquote><h1>876 链表的中间节点</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">middleNode</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        <span class="comment"># while fast.next != None and fast != None:</span></span><br><span class="line">        <span class="keyword">while</span> fast != <span class="literal">None</span> <span class="keyword">and</span> fast.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># while fast and fast.next:</span></span><br><span class="line">            slow  = slow.<span class="built_in">next</span></span><br><span class="line">            fast  = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)   当快指针走过一遍后停止<br>空间复杂度: O(1);  只用到若干额外变量</p></blockquote><p>问题：为什么while fast.next != None and fast != None 这个判断条件会报错？<br>这段代码的问题在于判断条件的顺序。在Python中，<code>and</code>操作符从左到右评估其操作数。如果<code>fast.next</code>不存在（即<code>fast.next</code>为<code>None</code>），那么<code>fast.next != None</code>将会抛出<code>AttributeError</code>异常，因为它试图访问<code>NoneType</code>对象的<code>next</code>属性。<br>你应该先检查<code>fast</code>是否为<code>None</code>，然后再检查<code>fast.next</code>是否为<code>None</code>。</p><h1>142 环形指针Ⅱ</h1><h2 id="快慢指针-需要推导">快慢指针(需要推导)</h2><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1719892312640.webp" alt="1719892312640.png"></p><p>设头节点到入口的距离为a，入口到相遇点的距离为b，相遇点到入口的距离为c</p><ol><li>结论：当快慢指针相遇时，慢指针还没有走完一整圈，所以<strong>环长</strong> = b+c</li><li>慢指针移动距离 = a+b</li><li>快指针移动距离 = a+b+k(b+c)  加若干倍的环长</li></ol><p>相对速度，慢指针不动，快指针每次走一步。快指针走(环长-1)步才能与慢指针相遇。所以慢指针移动的距离小于环长。<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1719974970974.webp" alt="1719974970974.png"></p><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1719975036150.webp" alt="1719975036150.png"></p><p>头节点移动是为了和慢指针相遇，从而找到入环的第一个节点</p><h3 id="伪代码">伪代码</h3><p>当没有到达链表末端<br>更新快慢指针<br>当快慢指针相遇时：<br>当慢指针与头节点没有相遇<br>更新慢指针和头节点<br>返回相遇时的slow</p><h3 id="代码">代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:  </span><br><span class="line">        fast, slow = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># if fast == slow :</span></span><br><span class="line">            <span class="keyword">if</span> fast <span class="keyword">is</span> slow :</span><br><span class="line">                <span class="keyword">while</span> slow != head:</span><br><span class="line">                    slow = slow.<span class="built_in">next</span></span><br><span class="line">                    head = head.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">return</span> slow</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>   <span class="comment"># 没有环</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)   慢指针与快指针相遇前后各走O(n)步<br>空间复杂度: O(1);  只用到若干额外变量</p></blockquote><h2 id="哈希">哈希</h2><h1>143 重排链表</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search_mid</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse_link</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>):</span><br><span class="line">        cur, pre = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre</span><br><span class="line">            pre = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="comment"># 反转结束后cur指向None, pre指向新的head</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderList</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        mid = self.search_mid(head)</span><br><span class="line">        head2 = self.reverse_link(mid)</span><br><span class="line">        <span class="keyword">while</span> head2 <span class="keyword">and</span> head2.<span class="built_in">next</span>:</span><br><span class="line">            tmp1, tmp2 = head.<span class="built_in">next</span>, head2.<span class="built_in">next</span></span><br><span class="line">            <span class="comment"># 连</span></span><br><span class="line">            head.<span class="built_in">next</span> = head2</span><br><span class="line">            head2.<span class="built_in">next</span> = tmp1</span><br><span class="line">            <span class="comment"># 更新</span></span><br><span class="line">            head = tmp1</span><br><span class="line">            head2 = tmp2</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>空间复杂度: O(1);  只用到若干额外变量</p></blockquote><h1>237 删除链表中的节点</h1><p>删除操作:<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720006928228.webp" alt="1720006928228.png"><br>不能访问之前的节点。</p><ol><li>把node的val更新为node下一个节点的值</li><li>node.next指向node下一个节点的next</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type node: ListNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 不能访问之前的节点</span></span><br><span class="line">        node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">        node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h1>19 删除链表的倒数第 N 个结点</h1><p>删除链表的倒数第 <code>n</code> 个结点<br>即为: 找到倒数第n+1个节点，做删除<br>找到的操作：</p><ol><li>遍历得到length, 再遍历一遍找到倒数n+1节点  --&gt; O(N)</li><li>dummy node ,然后用双指针？ --&gt; 待验证</li></ol><h2 id="双指针-2">双指针</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        <span class="comment"># 右边节点走n步骤</span></span><br><span class="line">        right = dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># left 和 right 的距离为n</span></span><br><span class="line">        <span class="comment"># [left, right]有n+1个节点，故right指向最后一个节点时，left指向倒数第n+1个节点</span></span><br><span class="line">        left = dummy</span><br><span class="line">        <span class="keyword">while</span> right.<span class="built_in">next</span>:</span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 删除操作</span></span><br><span class="line">        left.<span class="built_in">next</span> = left.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># return head # 不能返回头节点,因为头节点可能被删除</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>空间复杂度: O(1);  只用到若干额外变量</p></blockquote><h2 id="一般解法">一般解法</h2><p>两遍扫描：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 因为可能删除头节点，所以创建哨兵</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        cur = dummy.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 计算链表长度</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur = dummy</span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            <span class="comment"># 找到倒数第n+1节点</span></span><br><span class="line">            <span class="keyword">if</span> length - index == n:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)<br>空间复杂度: O(1);  只用到若干额外变量</p></blockquote><h1>83 删除排序链表中的重复元素</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 不用dummy,因为head若重复，可以删除后一个</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">and</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        <span class="comment"># 如果值相同就删除，否则移向下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)   每次循环要么删除一个节点，要么处理一个节点<br>空间复杂度: O(1);  只用到若干额外变量</p></blockquote><h1>82 删除排序链表中的重复元素 II</h1><p>找个相同元素后，如何对比的cur.next元素？<br>套一个循环，删除所有重复节点<br>思路：<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1720076201358.webp" alt="1720076201358.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 需要dummy, head可能会被删除</span></span><br><span class="line">        dummy = ListNode(<span class="built_in">next</span> = head)</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            val = cur.<span class="built_in">next</span>.val</span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>.val == val:</span><br><span class="line">                <span class="comment"># 当cur.next 存在，而且值为val</span></span><br><span class="line">                <span class="comment"># 删除cur.next</span></span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == val:</span><br><span class="line">                    cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span>        </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><blockquote><p>AC<br>时间复杂度: O(n)   每次循环要么删除一个节点，要么处理一个节点<br>空间复杂度: O(1);  只用到若干额外变量</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markov decision process</title>
      <link href="/posts/62cafd29.html"/>
      <url>/posts/62cafd29.html</url>
      
        <content type="html"><![CDATA[<h1>马尔可夫过程（Markov process，MP）</h1><p>就是离散时间的马尔可夫过程。<br>马尔可夫过程是一组具有马尔可夫性质的随机变量序列 $𝑠_1,⋯ ,s_{𝑡}$，其中下一个时刻的状态$s_{𝑡+1}$只取决于当前状态$s_{𝑡}$。我们设状态的历史为 $ℎ_𝑡={𝑠_1,𝑠_2,𝑠_3,…,𝑠_𝑡}$（$ℎ_𝑡$​包含了之前的所有状态），则马尔可夫过程满足条件：从当前$s_{𝑡}$转移到$s_{𝑡+1}$，它是直接就等于它之前所有的状态转移到$s_{𝑡+1}$。<br>$$<br>p(s_{t+1}|s_t) = p(s_{t+1}|h_t)<br>$$<br><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1717420388235.webp" alt="1717420388235.png"></p><p>从当前状态$s_t$转移到$s_{t+1}$的概率。</p><h1>马尔可夫奖励过程（Markov reward process, MRP）</h1><p>是马尔可夫链加上奖励函数。在马尔可夫奖励过程中，状态转移矩阵和状态都与马尔可夫链一样，只是多了<strong>奖励函数（reward function）</strong>。奖励函数 $R$ 是一个期望，表示当我们到达某一个状态的时候，可以获得多大的奖励。这里另外定义了折扣因子$𝛾$ 。如果状态数是有限的，那么$R$可以是一个向量。</p><h2 id="折扣因子">折扣因子</h2><ol><li>有些马尔可夫过程是带环的，它并不会终结，我们想避免无穷的奖励。</li><li>我们并不能建立完美的模拟环境的模型，我们对未来的评估不一定是准确的，我们不一定完全信任模型，因为这种<strong>不确定性</strong>，所以我们对未来的评估增加一个折扣。我们想把这个不确定性表示出来，希望尽可能快地得到奖励，而不是在未来某一个点得到奖励。</li><li>如果奖励是有实际价值的，我们可能更希望立刻就得到奖励，而不是后面再得到奖励（现在的钱比以后的钱更有价值）。</li><li>最后，我们也更想得到即时奖励。有些时候可以把折扣因子设为0（𝛾=0），我们就只关注当前的奖励。我们也可以把折扣因子设为1（𝛾=1），对未来的奖励并没有打折扣，未来获得的奖励与当前获得的奖励是一样的。</li><li>折扣因子可以作为强化学习智能体的一个超参数（hyperparameter）来进行调整，通过调整折扣因子，我们可以得到不同动作的智能体。</li></ol><h1>马尔可夫决策过程(Markov decision process,MDP)</h1><p>马尔可夫决策过程里面的状态转移 ：右图<br>马尔可夫奖励过程以及马尔可夫过程的状态转移：左图</p><ul><li>马尔可夫过程/马尔可夫奖励过程的状态转移是直接决定的。比如当前状态是$s$，那么直接通过转移概率决定下一个状态是什么。</li><li>对于马尔可夫决策过程，它的中间多了一层动作$𝑎$，即智能体在当前状态的时候，首先要决定采取某一种动作，这样我们会到达某一个黑色的节点。到达这个黑色的节点后，因为有一定的不确定性，所以当智能体当前状态以及智能体当前采取的动作决定过后，智能体进入未来的状态其实也是一个概率分布。在当前状态与未来状态转移过程中<strong>多了一层决策性</strong>，这是马尔可夫决策过程与之前的马尔可夫过程/马尔可夫奖励过程很不同的一点。在马尔可夫决策过程中，动作是由智能体决定的，智能体会采取动作来决定未来的状态转移。</li></ul><p><img src="https://datawhalechina.github.io/easy-rl/img/ch2/2.9.png" alt=""></p><h2 id="价值函数">价值函数</h2><p>引入Q函数(<strong>action-value function</strong>)，Q 函数定义的是在某一个状态采取某一个动作，它有可能得到的回报的一个期望，即<br>$$<br>Q_\pi(s,a)=\mathbb{E}<em>\pi[G_t\mid s_t=s,a_t=a]<br>$$<br>这里的期望其实是基于策略函数$\pi(a|s)$的。我们需要对策略函数进行一个加和，然后得到它的价值。对Q函数中的动作进行加和，就可以得到价值函数：<br>$$<br>V</em>\pi(s)=\sum_{a\in A}\pi(a\mid s)Q_\pi(s,a)<br>$$</p><h2 id="Bellman期望函数">Bellman期望函数</h2><p>状态价值函数和 Q 函数拆解成两个部分：即时奖励和后续状态的折扣价值</p><ul><li><p>状态价值函数：<br>Bellman期望方程(当前状态与未来状态之间的关联)：<br>$$<br>V_\pi(s)=\mathbb{E}<em>\pi\left[r</em>{t+1}+\gamma V_\pi\left(s_{t+1}\right)\mid s_t=s\right]<br>$$<br>$$<br>V_\pi(s)=\sum_{a\in A}\pi(a\mid s)Q_\pi(s,a)\quad(1)<br>$$</p></li><li><p>Q函数(动作价值函数)<br>Bellman期望方程：<br>$$<br>Q_\pi(s,a)=\mathbb{E}<em>\pi\left[r</em>{t+1}+\gamma Q_\pi\left(s_{t+1},a_{t+1}\right)\mid s_t=s,a_t=a\right]<br>$$<br>$$<br>Q_\pi(s,a)=R(s,a)+\gamma\sum_{s’\in S}p\left(s’\mid s,a\right)V_\pi\left(s’\right)\quad(2)<br>$$</p></li><li><p>Bellman期望方程变形</p><ol><li>当前状态的价值与未来状态价值之间的关联：将(2)带入(1),得到$$V_\pi(s)=\sum_{a\in A}\pi(a\mid s)\left(R(s,a)+\gamma\sum_{s’\in S}p\left(s’\mid s,a\right)V_\pi\left(s’\right)\right)$$</li><li>当前时刻的 Q 函数与未来时刻的 Q 函数之间的关联：将(1)带入(2),得到$$Q_{\pi}(s,a)=R(s,a)+\gamma\sum_{s’\in S}p\left(s’\mid s,a\right)\sum_{a’\in A}\pi\left(a’\mid s’\right)Q_{\pi}\left(s’,a’\right)$$</li></ol></li></ul><h2 id="Backup">Backup</h2><p>对于某一个状态，它的当前价值是与它的未来价值线性相关的。(可以由Bellman方程看出)<br>这些操作将价值信息从一个状态（或状态-动作对）的后继状态（或状态-动作对）转移回它。 每一个空心圆圈代表一个状态，每一个实心圆圈代表一个<strong>状态-动作对</strong>。<br><img src="https://datawhalechina.github.io/easy-rl/img/ch2/2.10.png" alt=""></p><p>可以由backup图推导出Bellman方程。</p><h2 id="策略评估-预测-prediction">策略评估(预测,prediction)</h2><p>给定马尔可夫决策过程$(S, A, P, R, \gamma)$和策略$\pi$，评估我们可以获得多少价值$V_\pi(s)$，即对于当前策略，我们可以得到多大的价值。<br>可以直接把<strong>贝尔曼期望备份（Bellman expectation backup）</strong>,变成迭代的过程，反复迭代直到收敛。这个迭代过程可以看作<strong>同步备份（synchronous backup</strong>的过程。</p><blockquote><p>同步备份是指每一次的迭代都会完全更新所有的状态，这对于程序资源的需求特别大。异步备份（asynchronous backup）的思想就是通过某种方式，使得每一次迭代不需要更新所有的状态，因为事实上，很多状态也不需要被更新。</p></blockquote><p>由backup图可以得到，把贝尔曼期望备份转换成动态规划的迭代：<br>$$<br>V^{t+1}(s)=\sum_{a\in A}\pi(a\mid s)\left(R(s,a)+\gamma\sum_{s’\in S}p\left(s’\mid s,a\right)V^t\left(s’\right)\right)<br>$$</p><blockquote><p>由于已知策略$\pi$(即$\pi$是固定的)，所以对于每个状态 $s$ 和动作 $a$，$\pi(a \mid s)$ 是预先确定的。<br>假设策略 $\pi$ 是一个确定性的策略（如贪婪策略），那么对于每个状态 $s$，$\pi(a \mid s)$ 要么是 1，要么是 0。而对于随机策略，$\pi(a \mid s)$ 可能是一个概率分布。</p></blockquote><p>为了消去$a$，使得价值函数$V$包含的变量都是只与状态有关:</p><ol><li><p>令期望即时奖励$r_{\pi}(s)$为<br>$$r_\pi(s) =\sum_{a\in A}\pi(a\mid s)R(s,a)$$</p></li><li><p>令期望转移概率$P_\pi(s’ \mid s)$为<br>$$<br>P_\pi(s’ \mid s) = \sum_{a \in A} \pi(a \mid s)p(s’ \mid s,a)<br>$$</p></li></ol><p>带入1和2，可以直接把它简化成一个马尔可夫奖励过程的表达形式：<br>$$<br>V_{t+1}(s) = r_\pi(s)+\gamma P_\pi(s’ \mid s)V_t(s’)<br>$$<br>这样迭代的式子中就只有价值函数与状态转移函数了。通过上面的迭代式，我们也可以得到每个状态的价值。</p><h2 id="控制">控制</h2><p>控制（搜索最佳策略）的输入是马尔可夫决策过程 $(S, A, P, R, \gamma)$，输出是最佳价值函数（optimal value function）$V^*$ 和最佳策略（optimal policy）$\pi ^ *$ 。控制就是我们去寻找一个最佳的策略，然后同时输出它的<strong>最佳价值函数以及最佳策略</strong>。</p><p>可以通过<strong>策略迭代</strong>和<strong>价值迭代</strong>来解决马尔可夫决策过程的控制问题。</p><h3 id="策略迭代">策略迭代</h3><p>策略迭代由两个步骤组成：策略评估和策略改进（policy improvement）。</p><p><img src="https://datawhalechina.github.io/easy-rl/img/ch2/2.21.png" alt=""></p><ol><li>策略评估，当前我们在优化策略$\pi$，在优化过程中得到一个最新的策略。我们先保证这个策略不变，然后估计它的价值，即给定当前的策略函数来估计状态价值函数。</li><li>策略改进，得到状态价值函数后，我们可以进一步推算出它的 Q 函数。得到 Q 函数后，我们直接对 Q 函数进行最大化，通过在 Q 函数做一个贪心的搜索来进一步改进策略。</li></ol><blockquote><p>得到状态价值函数后，我们就可以通过奖励函数以及状态转移函数来计算 Q 函数<br>$$<br>Q_{\pi_i}(s,a)=R(s,a)+\gamma\sum_{s^{\prime}\in S}p\left(s^{\prime}\mid s,a\right)V_{\pi_i}\left(s^{\prime}\right)<br>$$<br>对于每个状态，策略改进会得到它的新一轮的策略，对于每个状态，我们取使它得到最大值的动作，即$$\pi_{i+1}(s)=\arg\max_{a}Q_{\pi_{i}}(s,a)$$</p></blockquote><p>图 (b) 上面的线就是我们当前状态价值函数的值，下面的线是策略的值。</p><ul><li>策略迭代的过程与踢皮球一样。我们先给定当前已有的策略函数，计算它的状态价值函数。算出状态价值函数后，我们会得到一个 Q 函数。</li><li>我们对Q 函数采取贪心的策略，这样就像踢皮球，“踢”回策略。然后进一步改进策略，得到一个改进的策略后，它还不是最佳的策略，我们再进行策略评估，又会得到一个新的价值函数。</li><li>基于这个新的价值函数再进行 Q 函数的最大化，这样逐渐迭代，状态价值函数和策略就会收敛。</li></ul><blockquote><p>贝尔曼最优方程(<strong>Bellman optimality equation</strong>)<br>通过采取这种贪心操作（argmax 操作），我们就会得到更好的或者不变的策略。当改进停止后，我们就会得到一个最佳策略，我们取让 Q 函数值最大化的动作，Q 函数就会直接变成价值函数，即</p><p>$$Q_\pi\left(s,\pi’(s)\right)=\max_{a\in A}Q_\pi(s,a)=Q_\pi(s,\pi(s))=V_\pi(s)$$<br>故<strong>Bellman optimality equation</strong>为：<br>$$V_\pi(s)=\max_{a\in A}Q_\pi(s,a)$$<br>Q学习是基于贝尔曼最优方程来进行的，当取Q函数值最大的状态$(\max_{a’}Q^<em>(s’,a’):)$的时候可得$$Q^</em>(s,a)=R(s,a)+\gamma\sum_{s’\in S}p\left(s’\mid s,a\right)\max_{a’}Q^<em>\left(s’,a’\right)$$,为 Q 函数之间的转移。<br>反代得到状态价值函数的转移：$$V^</em>(s)=\max_{a}(R(s,a) + \gamma \sum_{s’ \in S}p(s’ \mid s,a)V^*(s’))$$</p></blockquote><h3 id="价值迭代">价值迭代</h3><p><img src="https://blog-1316756713.cos.ap-shanghai.myqcloud.com/bolg/1717659915724.webp" alt="价值迭代算法"></p><ol><li>价值迭代算法开始的时候，把所有值初始化，接着对每个状态进行迭代。</li><li>我们把式(2.23)代入式(2.24)，就可以得到式(2.22)。因此，我们有了式(2.23)和式(2.24)后，就不停地迭代，迭代多次后价值函数就会收敛，收敛后就会得到 $V^<em>$。我们有了 $V^</em>$ 后，一个问题是如何进一步推算出它的最佳策略。我们可以直接用 argmax 操作来提取最佳策略。</li><li>我们先重构 Q 函数，重构后，每一列对应的Q值最大的动作就是最佳策略。这样我们就可以从最佳价值函数里面提取出最佳策略。<br><img src="https://datawhalechina.github.io/easy-rl/img/ch2/2.46.png" alt=""></li></ol><blockquote><p>我们只是在解决一个规划的问题，而不是强化学习的问题，因为我们知道环境如何变化。</p></blockquote><h3 id="对比策略迭代和价值迭代">对比策略迭代和价值迭代</h3><p>这两个算法都可以解马尔可夫决策过程的控制问题。</p><ul><li>策略迭代分两步。首先进行策略评估，即对当前已经搜索到的策略函数进行估值。得到估值后，我们进行策略改进，即把 Q 函数算出来，进行进一步改进。不断重复这两步，直到策略收敛。</li><li>价值迭代直接使用<strong>贝尔曼最优方程</strong>进行迭代，从而寻找最佳的价值函数。找到最佳价值函数后，我们再提取最佳策略。</li></ul><h3 id="预测和控制总结">预测和控制总结</h3><p>总结如表所示，我们使用动态规划算法来解马尔可夫决策过程里面的预测和控制，并且采取不同的贝尔曼方程。</p><ul><li>对于预测问题，即策略评估的问题，我们不停地执行贝尔曼期望方程，这样就可以估计出给定的策略，然后得到价值函数。</li><li>对于控制问题，如果我们采取的算法是策略迭代，使用的就是贝尔曼期望方程；如果我们采取的算法是价值迭代，使用的就是贝尔曼最优方程。<br><img src="https://datawhalechina.github.io/easy-rl/img/ch2/table_1.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> RL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RL_note </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
